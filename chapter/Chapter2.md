## Chapter2 컴퓨터 하드웨어와 최적화
- 컴퓨터는 메모리에 저장된 명령을 실행하는 방법으로 작동한다.
  - 메모리에 저장되어 있는 데이터에 명령을 실행한다.
- 메모리는 각각 몇 비트의 여러 작은 워드로 나뉜다.
  - 대부분의 메모리 워드는 숫자 주소로 지정된다.
  - 몇 가지 특별한 메모리 워드를 레지스터라고 한다.
    - 특정 레지스터에는 실행할 다음 명령의 주소가 들어 있다.

## 2.1 C++은 컴퓨터의 거짓말을 믿습니다.
- 컴퓨터에는 기본적으로 무한한 char 크기를 갖는 주소를 지정할 수 있는 메모리가 있다.
- 유효한 메모리 주소와는 다른 nullptr이라는 특수 주소가 있다.
- C++ 프로그램은 명령문을 순서대로 실행하는 것처럼 작동하기만 하면 된다.
- C++11 부터는 단일 실행 주소만 있다고 믿지 않는다.
- 특정 메모리 주소는 일반 메모리가 아닌 장치 레지스터가 될 수 있다.
- C++11은 `std::atomic<>`이라는 메모리를 잠시 동안 단순한 선형 바이트 저장소인 것처럼 작동하게 만드는 것을 제공한다.

## 2.2 컴퓨터의 진실
### 2.2.1 메모리는 느립니다
- 메인 메모리는 마이크로프로세서에 있는 **게이트**와 **레지스터**보다 매우 느리다.
- **메모리에 접근하는 비용**은 **프로세서의 다른 비용들을 압도**한다.
- [폰 노이만 병목현상](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0)

### 2.2.2 메모리는 워드 단위로 접근합니다
- `int`, `double`, `포인터`처럼 여러 바이트를 갖는 자료형을 가져올때 해당 데이터를 구성하는 바이트가 실제 메모리에서는 **두개의 워드**에 걸쳐 있을 수 있다. (unaligned memory access : 정렬되지 않은 메모리 접근)
  - 두 워드를 읽어야 하기 때문에 모든 바이트가 같은 워드에 있을 때보다 시간이 **2배**로 걸린다.
- C++ 컴파일러는 구조체 내 각 필드의 **시작 주소가 필드 크기의 배수인 바이트 주소가 되도록 정렬**한다.
  - 사용되지 않는 데이터가 구조체에 포함되어 구멍이 생기는 문제를 초래한다.
  - 구조체에서 **데이터 필드**의 **크기**와 **순서**에 주의를 기울여야한다.

### 2.2.3 메모리마다 접근 속도가 다릅니다
- 캐시메모리
  - 일반적으로 가장 오래전에 사용된 데이터를 삭제한다.
     - 더 많이 사용하는 메모리 위치에 더 빠르게 접근할 수 있다.
  - 캐시에 없는 데이터를 1바이트만 읽어도 근처에 있는 바이트가 함께 캐싱된다.
     - 인접한 위치의 메모리가 멀리 떨어진 곳의 메모리보다 더 빨리 접근할 수 있다.

### 2.2.4 워드를 저장하는 방법에는 빅 엔디언과 리틀 엔디언이 있습니다
- 빅엔디안
  - 첫 번째 바이트 주소에 **최상위 비트**가 오는 방법
- 리틀엔디안
  - 첫 번째 바이트 주소에 **최하위 비트**가 오는 방법

### 2.2.5 메모리는 한정된 자원입니다
- 컴퓨터의 메모리는 무한하지 않다.
  - 운영체제는 무한한 메모리라는 환상을 유지하기 위해 가상 메모리를 사용하지만 가상 메모리는 속도가 느리다.
- 캐시 메모리 용량을 늘리는 것은 비용이 많이 든다.

### 2.2.6. 명령 실행은 느립니다
- 현대의 데스크톱 컴퓨터는 아무 방해도 받지 않을 경우 놀라운 속도로 명령을 실행한다.
  - 각 명령을 수행하는 시간이 빠른것은 아니다.
  - 프로세서에는 동시 작업 중인 명령 파이프라인이 포함되어 있다.
  - 프로세서가 강력할수록 파이프라인이 복잡해져 명령 실행을 십수 단계로 나누기 때문에 더 많은 명령을 동시에 처리할 수 있다.
- 명령 A가 명령 B 에 필요한 값을 계산한다고 가정하면, 명령 B는 명령 A가 결과를 생성할 때까지 값을 계산할 수 없다.
  - 이 때문에 **파이프라인 스톨**이 발생한다.
  - 두 명령의 실행이 겹치지 않기 때문에 명령의 실행이 잠시 중단된다.

### 2.2.7 컴퓨터는 의사 결정을 잘 하지 못합니다
- 컴퓨터가 결정을 내릴 때도 **파이프라인 스톨**을 초래할 수 있다.
- 점프나 함수 호출 같은 명령어들은 실행 주소를 임의의 새 값으로 변경한다.
- 다음 명령은 점프 명령을 처리하는 중 실행 주소가 갱신될 때까지 메모리에서 잠시 동안 읽을 수 없으며 파이프라인에 놓일 수도 없다.

### 2.2.8 프로그램 실행에는 여러 스트림이 있습니다
- 운영체제에서 실행되는 모든 프로그램은 동시에 실행 중인 다른 프로그램들(유지 관리 프로세스)과 주변 장치 및 컴퓨터를 공유한다.
- 운영체제는 짧은 시간 동안 각 스레드를 실행한 다음 다른 스레드나 다른 프로세스로 콘텍스트를 전환한다.
- 콘텍스트 전환
  - 운영체제가 어떤 프로그램의 스레드에서 동일한 프로그램의 다른 스레드로 전환한다면 일시 중단할 스레드의 프로세서 레지스터를 저장하고, 실행을 다시 시작할 스레드의 저장된 레지스터를 불러온다.
  - **상당한 비용**이 든다.

### 2.2.9 운영체제 기능을 호출하는 비용은 높습니다
- OS 커널은 프로그램이 운영체제에 시스템 호출을 할 수 있도록 모든 프로그램이 속한 메모리에 접근할 수 있어야 한다.
- **시스템 콜** 비용이 한 프로그램의 **단일 스레드 내**에서 **함수를 호출**하는 것보다 **수백 배** 더 크다.