## 문자열 최적화
### 문자열이 문제인 이유
- 문자열에는 구현과 관계없이 비용이 높은 함수가 존재한다.
- 이 함수들은 메모리를 동적으로 할당하고, 표현식에서 값처럼 작동하며 내부에서 복사를 많이 한다.

1. 문자열은 메모리를 동적으로 할당한다.
    - 문자열은 필요한 문자열 길이보다 더 큰 공간을 할당한다.
    - 요청한 문자열 길이보다 큰 2의 거듭제곱값으로 할당을 하는식이다.
    - 동적으로 할당되기에 수동 해제 방법보다 편리하다.
    - 동적으로 할당되기에 최적화가 필요한 부분이 될 수 있다.
2. 문자열은 값이다.
    - 문자열은 **대입문**과 **표현식**에서 **값**처럼 작동한다.
    ```cpp
    std::string s1, s2;
    s1 = "HELLO";
    s2 = s1;
    s1[0] = 'T';
    ```
    - s1은 TELLO, s2는 HELLO가 된다.
3. 문자열을 복사를 많이 한다.
    - 문자열은 값처럼 작동하므로 문자열을 수정하더라도 다른 문자열은 수정되지 않아야 한다.
    - 하지만 문자열에는 내용을 수정하는 함수들이 있어서 문자열은 복사본을 가진 것처럼 작동해야 한다. `(COW : copy-on-write)`
    - c++11 표준에서는 COW 방법이 문제가 발생할 수 있어 허용하지 않는다.
    - C++11 표준 이후에는 **우측값 참조**와 **이동 문법** 덕분에 복사하는 비용이 많이 낮아졌다.
    - 문자열이 **우측값 표현식**이라면 포인터를 복사하기 때문에 비용이 낮으며 복사본을 만들지 않아도 된다.

### 문자열 최적화 1
```cpp
std::string remove_ctrl(std::string s)
{
    std::string result;
    for (int i = 0; i < s.length; i++)
    {
        if (s[i] >= 0x20)
        {
            result = result + s[i];
        }
    }
    return result;
}
```
- 위 함수에서 `result = result + s[i]`에서 성능의 문제가 발생할 수 있다.
- 문자열 연결 연산자는 비용이 높다.
- 위 코드에서 문자열의 길이가 100이라면 **저장 공간을 만들기 위해** 메모리 관리자를 100번 호출하고 **저장 공간을 해제하기 위해** 100번 호출하게 된다.

#### 1. 문자열의 내용을 변경하는 연산자로 임시 문자열 제거하기
- 위 코드에서 `result += s[i];`로만 바꿔줘도 13배가 개선된다.
```cpp
std::string remove_ctrl_mutating(std::string s)
{
    std::string result;
    for (int i = 0; i < s.length(); ++i)
    {
        if (s[i] >= 0x20)
        {
            result += s[i];
        }
    }
    return result;
}
```
#### 2. 저장 공간을 예약해 재할당 줄이기
- 위 코드에서 3,4번째줄 사이에 `result.reserve(s.length());`코드를 통해 저장 공간을 미리 예약한다.
- 위 작업으로 1번의 결과보다 17%정도의 성능향상을 할 수 있다.
```cpp
std::string remove_ctrl(std::string s) 
{
    std::string result;
    result.reserve(s.length());
    for (int i = 0; i < s.length(); ++i) 
    {
        if (s[i] >= 0x20)
        {
            result += s[i];
        }
    }
    return result;
}
```
#### 3. 문자열 인수의 복사 제거하기
- 함수의 인자에 참조를 건다 `std::string const& s`
- 하지만 의외로 이 방법은 **2번**의 방법보다 **8%**가 느려졌다.
- 비주얼 스튜디오 2010은 함수 호출 시 문자열의 값을 복사하므로 인수의 복사를 제거하면 할당 비용을 절약할 수 있다.
- 실제로 비용이 절약되지 않았거나 s를 문자열 참조로 바꿔서 절약한 비용을 다른 곳에서 소비중이어야 한다.
- 참조 변수는 포인터로 구현된다.
- 위 코드에서는 s가 참조라 포인터를 역참조 해야한다.
- 따라서 역참조 하는 비용 때문에 성능이 저하된 것이다.
```cpp
std::string remove_ctrl_ref_args(std::string const& s) 
{
    std::string result;
    result.reserve(s.length());
    for (int i = 0; i < s.length(); ++i) 
    {
        if (s[i] >= 0x20)
        {
            result += s[i];
        }
    }
    return result;
}
```
#### 4. 반복자로 포인터 역참조 제거하기
- 반복문을 `for(auto it = s.begin(), end = s.end(); it !=end; ++it)`로 바꿔주면 3번에 의한 성능 저하 문제를 해결할 수 있다.
- `s.end()`값을 `end = s.end();`에서 반복문을 초기화하는 부분에 캐싱하면 2N번의 간접 참조 비용을 절약할 수 있다. (N은 문자열의 길이)
```cpp
std::string remove_ctrl_ref_args_it(std::string const& s)
{
    std::string result;
    result.reserve(s.length());
    for (auto it = s.begin(), end = s.end(); it != end; ++it)
    {
        if (*it >= 0x20)
        {
            result += *it;
        }
    }
    return result;
}
```
#### 5. 반환된 문자열 값의 복사 제거하기
- 인자에 `std::string^ result`를 추가하고 반복문전 `result.clear();`를 해주면 2%의 성능 개선을 기대할 수 있다.
```cpp
void remove_ctrl_ref_result_it(std::string& result, std::string const& s)
{
    result.clear();
    result.reserve(s.length());
    for (auto it = s.begin(), end = s.end(); it != end; ++it)
    {
        if (*it >= 0x20)
        {
            result += *it;
        }
    }
}
```
#### 6. 문자열 대신 문자 배열 사용하기
- `std::string`대신 C스타일의 문자열 함수를 사용하면 성능 향상을 기대할 수 있다.
- 아래처럼 작성한다면 5번항목의 함수보다 6배가 빠르고 처음 함수보다 170배가 빠르다.
- 함수 호출을 없애고 캐시 지역성을 향상했기 때문이다.
```cpp
void remove_ctrl_cstrings(char* dest, char const* src, size_t size)
{
    for (size_t i = 0; i < size; ++i)
    {
        if (src[i] >= 0x20)
        {
            *dest++ = src[i];
        }
    }
    *dest = 0;
}
```
### 문자열 최적화 2
1. 더 좋은 **알고리즘** 사용하기
- `remove_ctrl()` 함수는 한 번에 하나의 문자를 결과 문자열로 복사하는 알고리즘을 사용한다.
- 이것을 아래와 같이 부분 문자열 전체를 결과 문자열로 이동하여 개선한다면 7배가 빨라진다.
```cpp
std::string remove_ctrl_block(std::string s) 
{
    std::string result;
    for (size_t b = 0, i = b, e = s.length(); b < e; b = i + 1) 
    {
        for (i = b; i < e; ++i) 
        {
            if (s[i] < 0x20)
            {
                break;
            }
        }
        result = result + s.substr(b, i - b);
    }
    return result;
}
```
- substr()은 여전히 **임시 문자열**을 생성하기 때문에 **append() 멤버 함수**를 사용하면 **임시 문자열**을 만들지 않고도 부분 문자열을 복사할 수 있다.
```cpp
std::string remove_ctrl_block_append(std::string s) 
{
    std::string result;
    result.reserve(s.length());
    for (size_t b = 0, i = b; b < s.length(); b = i + 1) 
    {
        for (i = b; i < s.length(); ++i) 
        {
            if (s[i] < 0x20)
            {
                break;
            }
        }
        result.append(s, b, i - b);
    }
    return result;
}
```
- std::string의 erase() 멤버 함수를 사용해 매개변수의 문자를 제거하는 방법으로 성능을 개선할 수도 있다.
```cpp
std::string remove_ctrl_erase(std::string s)
{
    for (size_t i = 0; i < s.length(); )
    {
        if (s[i] < 0x20)
        {
            s.erase(i, 1);
        }
        else
        {
            ++i;
        }
    }
    return s;
}
```
2. 더 좋은 **컴파일러** 사용하기
- `Visual Studio 2013`은 일부 함수를 빠르게 만들어주는 이동 문법을 구현했지만 테스트 결과는 뒤죽박죽이다.
- 디버거에서 실행할 경우 2013이 2010보다 5~15% 더 빠르다.
- `Visual Studio 2015`또한 `Visual Studio 2010`보다 느리게 측정이 되었다.

3. 더 좋은 **문자열 라이브러리** 사용하기
- std::string은 사용하는 사람이 자유롭게 구현할 수 있도록 애매하게 정의되었다.
- 다른 표준 라이브러리 컨테이너와 마찬가지로 문자열의 각 문자에 접근할 수 있는 반복자를 제공한다.
- operator[]을 사용해 요소에 접근하는 배열식 색인 표기법을 제공한다.
- 이런 std::string의 작동 떄문에 최적화 상황에서 몇 가지 약점이 발생한다.
    1. 더 많은 기능을 가진 std::String 라이브러리 채택
        - 부스트 문자열 라이브러리
        - C++ 문자열 툴킷 라이브러리
    2. std::stringstream을 사용해 값 의미를 피하기
    3. 새로 구현된 문자열을 채택하기
        1. std::string_view
        2. folly::fbstring
        3. 문자열 클래스의 도구 상자
        4. C++03 표현식 템플릿
        5. rope<T,alloc>
4. 더 좋은 **할당자** 사용하기

### 문자열 변환 연산 제거하기
- C++에서 가장 복잡한 부분중 하나는 문자열의 종류가 여러 가지라는 것이다.

1. C 문자열에서 std::string으로 변환
    - 컴퓨터 사이클이 낭비되는 원인 중 하나는 NULL로 끝나는 문자열에서 `std::String`으로의 불필요한 변환 연산 때문이다.
2. 문자 인코딩 사이의 변환

