## Chapter3 성능 측정
#### 소프트웨어 제작사들이 **시간 측정**을 위해 만든 도구
1. 프로파일러
   - 일반적으로 컴파일러 제작사가 컴파일러와 함께 제공한다.
   - 프로그램 실행 중에 호출된 각 함수를 수행하는 데 걸린 누적 시간을 표로 정리한 뒤 보고서를 작성해 준다.
2. 소프트웨어 타이머
   - 개발자가 만들 수 있는 도구
   - 계산에 구속되지 않는 시간 측정에도 유용하다.
1. 노트
   - 구식이지만 없어서는 안 될 중요한 도구

## 3.1 사고방식 최적화
### 3.1.1 성능은 반드시 측정해야 합니다
- 최적화가 끝났다고 생각했던 코드를 더 효율적인 코드로 바꿀 수도 있고 최적화가 제대로 되지 않았다고 생각했는데 가장 최적화가 잘된 코드였을수도 있다.
  - 측정만이 최적화 게임의 승패를 알려준다.
- 테스트 가능한 **예측**을 만들고 적어둔다.
- 코드 변경 사항을 **기록**한다.
- 사용 가능한 **최고의 측정기**로 측정한다.
- 실험 결과의 자세한 내용을 **보관**한다.

### 3.1.2 최적화를 하는 사람은 맹수 사냥꾼입니다
- 속도가 빨라졌다고 하려면 **무작위화**, **샘플링**, **신뢰 수준**으로 입증해야 한다.
- 성능 개선은 운영체제나 컴파일러 같은 요소에 따라 달라질 수 있다.
  - 시스템이 바뀌거나 시간이 흐르면서 큰 영향을 미치지 않을 수도 있다.
  - 극적으로 개선된 성능은 코드를 새로운 시스템으로 이식하더라도 저하되는 일이 없다.

### 3.1.3 90/10 규칙
- 프로그램 코드의 `10%`가 실행 시간의 `90%`를 소비한다
- 특정 코드 블록이 매우 빈번하게 실행되며 코드의 다른 부분은 거의 실행되지 않는다.
- 최적화를 하려면 자주 실행되는 `10%`가 어딘지 찾아야 한다.

### 3.1.4 암달의 법칙
- 코드의 일부를 최적화 할 때 전반적인 성능이 얼마나 향상되었는지 설명하는 법칙

![암달](https://user-images.githubusercontent.com/21440957/78467487-51167b80-7748-11ea-802b-228ddf3a656f.PNG)
- S<sub>t</sub> : 최적화로 프로그램 전체 실행 시간이 얼마나 개선되었는지 나타내는 비율
- P : 최적화할 부분이 기존 프로그램 전체 실행 시간에서 차지하는 비율
- S<sub>p</sub> : P에서 최적화로 얼마나 개선되었는지 나타내는 비율

## 3.2 실험 수행
### 3.2.1 연구 노트를 보관하세요  
- 각 테스트를 **문서화**하면 반복 수행을 빠르게 할 수 있다.
- **문서화** 하지 않았다면 이전 실험을 다시 수행해 실행 결과를 얻어야 한다.

### 3.2.2 성능 측정 기준과 목표 설정
#### 최적화와 관련된 두가지 지표
  1. 최적화 이전의 성능 축정 기준
     - 성능 개선을 시도할 때마다 성공 여부를 가려준다.
     - 이해 당사자에게 최적화에 쓰이는 비용의 정당성을 이해시키는데 중요한 지표가 된다.
  2. 성능 목표
      - 최적화는 노력에 대한 보상이 점점 줄어드는 과정이므로 성능 목표를 설정하는 것이 중요하다.

#### 최적화 관련 수치
1. 시작 시간
    - 일반적으로 `main()` 프로시저에 들어가는 시점부터 `main` 루프에 들어가는 시점
2. 종료 시간
    - 사용자가 닫기 아이콘을 클릭하거나 명령을 입력한 후부터 프로세스가 실제로 종료될 때까지 걸린 시간
    - 메인 윈도우가 종료 명령을 받는 시점부터 `main()` 함수를 빠져나오는 시점까지의 경과 시간
3. 응답 시간
    - 평균 시간 또는 최악의 경우를 고려한 시간
    - 응답 시간은 10의 거듭제곱 단위로 분류할 수 있다.
        - 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
        - 0.1초 ~ 1초 : 사용자가 제어권을 가짐
        - 1 ~ 10초 : 컴퓨터에 제어권이 있음
        - 10초 이상 : 커피 마실 시간
4. 처리량
    - **응답 시간**의 역수
    - 테스트 작업량 일부에 대한 단위 시간당 평균 작업 수

### 3.2.3 측정한 것만 개선할 수 있습니다.
- 단일 함수, 서브 시스템, 태스크, 테스트 케이스를 최적화 하는 것과 전체 프로그램의 성능을 향상하는 것은 전혀 다른 작업이다.
- **컴퓨터 환경**에 따라 테스트 설정이 달라지기 때문에 테스트에서 성능 향상을 보아도 실전에서 **동일한 성능 향상을 장담하는 경우**는 거의 없다.

## 3.3 프로그램 실행 프로파일
#### 프로파일러
- 어떤 프로그램이 어디에 시간을 쓰는지 통계 자료를 생성하는 프로그램
- 각각의 문장이나 함수의 **실행 빈도**, 각 함수 실행에 걸린 **누적 시간**을 보여주는 보고서를 만든다.
- 프로파일러를 사용하면 최적화할 여지가 있는 후보를 탁원하게 찾을 수 있지만 완벽하지는 않다.
- 프로파일러는 한 분야에서만 능력을 발휘한다.
- 프로파일러가 알아내지 못한 최적화 기회가 있을 수 있으며 프로파일러 출력을 해석할 때도 문제가 있을 수 있다.

## 3.4 시간이 오래 걸리는 코드
### 3.4.1 측정 시간 '조금' 배우기
- 측정 실험을 할 때는 완벽함을 망치는 여러 **편차**에 맞서 싸워야 한다.
- **편차**에는 **불규칙 편차**와 **체계적 편차** 두 가지 유형이 있다.
    - **불규칙 편차**는 측정할 때마다 서로 다른 영향을 미친다.(정밀도)
    - **체계적 편차**는 모든 측정에 유사한 영향을 미친다.(진도)
- 편차의 측정 지표는 **정밀도**, **진도**가 있다.

#### 정밀도, 진도, 정확도
- 불규칙 편차가 없는 측정은 정밀하다.
  - 동일한 현상이 반복적으로 측정 가능하며 측정한 값이 서로 가깝다면 측정은 정밀하다.
- 체계적 편차가 없는 측정은 충실하다(진도가 높다)
  - 동일한 현상을 반복적으로 측정하며 모든 결과의 평균이 실제 값에 가깝다면 측정은 충실하다.
- 측정의 정확도는 각각의 측정이 실제 값에 얼마나 근접한가에 따라 결정되는 느슨한 개념이다.

#### 시간 측정
- 시계를 사용하여 소요시간과 비율을 측정한다.

#### 측정 해상도
- 측정을 나타내는 크기의 단위이다.

### 3.4.2 컴퓨터로 시간 측정하기
#### 윈도우 GetTickCount() 함수
- 1 밀리초 해상도의 틱 카운트를 부호 없는 32비트 정수로 반환
- 위 함수를 업데이트한 버전인 GetTickCount64()는 틱카운트를 64비트의 부호 없는 정수로 반환한다.

#### 작업에 걸린 시간 구하기
```cpp
    DWORD start = GetTickCount();
    DWORD end = GetTickCount();
    cout << end - start << " ms"<<endl;
```
#### 지연 시간
- **작업을 시작**하라고 명령을 내린 시점부터 **실제로 명령을 시작**하는 시점까지의 **경과 시간**
- 시간 측정에서 지연 시간이 발생하는 이유
  - 시계를 시작, 실험을 실행, 시계를 멈추는 작업을 순차적으로 수행하기 때문이다.
- 윈도우 타이밍 함수또한 지연시간이 존재한다.

#### 비결정적 행동
- 컴퓨터는 매우 복잡한 장치라 내부 상태의 변화 때문에 측정할 때 **무작위적인 편차**가 발생하게 된다.
- 운영체제는 예측할 수 없는 방법으로 작업을 예약하므로 측정 도중 프로세서와 메모리 버스의 활동이 달라질 수 있다.

### 3.4.3 측정 장애물 극복하기
- 컴퓨터로 시간을 측정하는것은 여러가지 제한 사항이 존재한다.

#### 컴퓨터로 시간을 측정하는건 불가능하다?
- 최적화를 이끌어 나가기 위해서는 1% ~ 2% 정도의 정확도만으로 충분하다.
- **상대적 성능**을 측정한다.
  - 상대적 성능이란 최적화된 코드의 실행 시간 대 기존 코드의 **실행 시간의 비율**이다.
- **모듈 테스트**를 측정해 반복성을 향상시키자.
  - 모듈 테스트랑 준비된 입력 데이터를 사용해 단계별로 수행하는 서브시스템 테스트이다.
- **측정 기준**을 사용해 성능을 튜닝하자.
  - 응답 시간의 값을 측정하는 대신 측정 기준, 평균, 붓난과 같은 모집단 통계, 지수평활법을 거친 응답 시간의 평균을 수집할 수 있다.
- 여러 차레 반복한 결과의 **평균**으로 정확도를 높이자.
  - 평균을 통해 단일 측정의 정확도를 향상시킬 수 있다.
- **우선순위**를 높여 운영체제의 비결정적 행동을 줄이자.
  - `SetPriorityClass()` 함수를 통해 우선순위를 조작할 수 있다.
- 비결정적인 무언가가 발생해도 **전진**하자.
  - 개발자가 큰 성능 변화를 가져오는 부분만 받아들인다면 **방법론**에 크게 신경 쓸 필요가 없다.

### 3.4.4 스톱워치 클래스 만들기
- [스톱워치 클래스](/Code/CustomTimer.h)
  - C++ 11 이상에서 사용가능한 `chrono`라이브러리를 쓴 `Timer` 클래스이다.
  - 운영체제 간에 이식이 가능하다.
- [스톱워치 클래스2](/Code/CustomTimer2.h)
  - C++ 버전과 운영체제에 상관없이 이식성이 있다.
  - 윈도우와 리눅스에서 `clock()`함수가 약간 다르게 측정 될 수 있다.

### 3.4.5 **테스트 하네스**에서 실행 시간이 긴 함수 측정하기
- 하나의 함수를 최적화 후보로 정했다면 함수를 여러번 호출하는 **테스트 하네스**를 구축해 쉽게 작업이 가능하다.

## 3.5 코드 비용 추정하기
- 식별된 코드 블록에서 각 문장의 비용을 추정해야 한다.
- 대부분 코드 비용을 높이는 고비용 문장이나 구조체를 찾는 약식 검사로 진행할 수 있다.

### 3.5.1 C++ 문장의 비용 추정하기
- 메모리에 접근하는 시간은 느리다.
- 문장이 메모리를 몇 번 읽고 썼는지 세는 것을 통해 비용 추정을 진행한다.

### 3.5.2 반복문의 비용 추정하기
- 자주 실행하게 만드는 요인 중 하나는 문장이 반복문 안에 있는 것이다.
  - 문장의 비용은 실행 횟수만큼 **곱**해진다.

#### 중첩 반복문에서 반복 횟수 추정하기
- 중첩 반복문에서도 문장의 실행 비용은 곱연산이 적용된다.
- 반복문이 다른 반복문 안에 중첩되어 있을 경우 
  - 코드 블록의 반복 횟수는 내부 반복문의 반복 횟수와 외부 반복문의 반복 횟수를 곱한 값이다.

#### 변수의 반복 횟수로 반복문 추정하기
- 모든 반복문이 반복 횟수를 명확하게 제공하지는 않는다.
- 많은 반복문은 어떤 조건이 발생할때까지 반복한다.
  - 변수의 반복 횟수로 추정할 수 있다.

#### 묵시적 반복문 인식하기
- 이벤트를 처리하는 프로그램은 최상위 수준에서 묵시적 루프를 돌린다.
- 이 반복문은 프레임워크에 숨겨져 있어 프로그램에서는 보이지 않는다.

#### 거짓 반복문 인식하기
- do, while문이 모두 반복문은 아니다.

## 3.6 최적화할 코드를 찾는 다른 방법
- 코드에 익숙한 개발자는 직감만으로 런타임 전체에 영향을 줄 수 있는 코드 영역에 대한 가설을 세운다.
  - 그 영역에서 한 부분을 변경해 전체 성능이 향상되는지 여부를 확인하는 실험을 수행하기도 한다.
- 자기 혼자만의 만족을 추구하는 게 아닌 이상 권하지 않는다.
  - 혼자서 감으로 작업을 진행한다면 제대로된 결과를 도출하기 힘들다.
  - 결과를 낸다고 해도 팀원들이 방법론에 의문을 제기할 것이다.