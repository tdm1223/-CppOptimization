## 알고리즘 최적화
### 알고리즘의 시간 비용
- O(1) 또는 상수 : 가장 빠른 알고리즘. 입력값에 상관ㅇ벗는 고정 비룔이다.
- O(logN) : 여러번 호출해도 괜찮다. 대표적인 예로는 이진 검색 알고리즘
- O(N) 또는 선형 시간 : 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다.
- O(NlogN) : 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 빠른 알고리즘. 대처 가능한 수준이나 불필요한 호출할 필요는 없다.
- O(N<sup>2</sup>), O(N<sup>3</sup>) ... : 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 매우 빠르다. 입력값이 크다면 사용을 고려해야 한다.
- O(2<sup>n</sup>) : 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 매우 빠르다. 입력값이 작은 경우에만 사용해야 한다. 대표적인 예로는 TSP 알고리즘

1. 최선의 경우, 최악의 경우, 평균의 경우 시간 비용
- 알고리즘은 입력값의 순서에 따라 빨라지기도 하고 느려지기도 하므로 성능이 중요한 코드에서 어떤 알고리즘을 사용할지 정할 때는 **최악**을 고려해야 한다.
- 입력값이 대부분 정렬되어있다는 사실을 알고 있다면 최선의 경우에서 특히 좋은 성능을 보이는 알고리즘을 선택해 프로그램의 실행 시간을 향상시킬 수 있다.

2. 상환 시간 비용
- 입력값이 클 때 **전체 시간 비용**을 **입력값**으로 나눈 **평균 시간 비용**

3. 기타 비용
- 어떤 알고리즘은 중간 결과를 저장해 실행 속도를 높일 수 있다.
    - 중간 저장 비용이 발생할 수 있다.
- 어떤 알고리즘은 병렬화로 실행 속도를 높일 수 있다.
    - 이 경우에는 병렬로 실행 가능한 프로세서가 많아야 한다.

### 검색과 정렬을 최적화하는 툴킷
- 검색 및 정렬을 **최적화 하는 툴킷**에 포함되는 기능
    1. 평균의 경우에 big-O 시간 비용이 많은 알고리즘을 시간 비용이 더 적은 알고리즘으로 바꿀 수 있다.
    2. 데이터가 어떤 특징을 가진다면 해당 특징을 활용해 가장 좋은 big-O 시간 비용을 갖는 알고리즘을 선택할 수 있다.
    3. 알고리즘을 수정해 성능을 향상할 수 있다.

### 효율적인 검색 알고리즘
1. 검색 알고리즘의 시간 비용
2. 모든 검색 알고리즘은 n이 작으면 같다

### 효율적인 정렬 알고리즘
1. 정렬 알고리즘의 시간 비용
2. 최악의 경우에 정렬 알고리즘 교체하기
3. 입력 데이터의 특성 활용하기

### 최적화 패턴
1. 사전 계산
2. 지연 계산
3. 배칭
4. 캐싱
5. 특수화
6. 더 큰 조각 선택하기
7. 힌팅
8. 예상 경로 최적화
9. 해싱
10. 이중 검사