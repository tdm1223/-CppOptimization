## 동적 할당 변수 최적화
### C++ 변수
- 모든 C++ 변수는 메모리에 고정된 레이아웃을 가지며 레이아웃의 크기는 **컴파일 타임**에 결정된다.
- 프로그램이 변수의 크기를 바이트 단위로 얻고 그 변수를 가리키는 포인터를 선언하는것을 허용한다.
- 변수의 레이아웃을 비트 단위로 지정하는 것은 허용하지 않는다.

1. 변수의 저장 기간
- 모든 변수는 수명을 갖는다.
- 정적 저장 기간
    - **컴파일러**가 예약해둔 메모리에 상주한다.
    - **고정 메모리 주소**에서 **고정 크기**를 차지한다.
    - 메모리 주소는 **컴파일 타임**에 결정된다.
    - 프로그램이 종료될 때까지 예약되어 있다.
    - 정적 변수를 위한 저장 공간을 생성하는 런타임 비용은 없으나 저장 공간을 재사용할 수는 없다.

- 스레드 지역 저장 기간
    - C=+11 이후 표준으로 작성된 프로그램은 스레드 지역 저장 기간을 갖는 변수를 선언할 수 있다.
    - 스레드에 진입할 때 생성되어 스레드가 끝날 때 파괴된다. (수명은 스레드의 수명과 같다고 할 수 있다.)

- 자동 저장 기간
    - **함수 호출 스택**에서 컴파일러가 예약해둔 메모리에 상주한다.
    - **컴파일 타임**에 메모리 크기가 결정되고, 자동 변수는 각 함수 호출 **스택 포인터**에서 고정된 오프셋 위치를 가진다.
    - 중괄호로 둘러싸인 코드 블록 안에서 존재한다.
    - 선언된 곳에서 생성되어 코드 블록을 빠져나갈 때 파괴된다.
    - 한 번에 사용할 수 있는 **메모리 크기**는 **제한**이 있다.
    - 깊이가 매우 깊은 재귀나 중첩된 함수 호출 때문에 제한된 메모리 크기를 초과하면 **스택 오버플로**가 발생한다.

- 동적 저장 기간
    - 프로그램에서 요청한 메모리에 상주한다.
    - C++ 런타임 시스템 함수와 프로그램 대신 메모리 풀을 관리하는 자료구조로 구성된 **메모리 관리자**를 호출한다.
    - `new`으로 변수를 동적으로 생성한다.
    - `delete`로 변수의 메모리를 메모리 관리자로 반환한다.
    - 동적 변수의 주소는 **런타임**에 결정된다.
    - 소비하는 저장 공간의 크기가 제한되어 있지 않으며 시간에 따라 변할 수 있다.
    - 자동 변수와 달리 동적 변수가 사용하는 메모리를 관리하려면 **런타임 비용**이 많이 필요하다.

2. 변수의 소유권
3. 값 객체와 엔티티 객체

### C++ 동적 변수 API
1. 스마트 포인터는 동적 변수의 소유권을 자동화함
2. 동적 변수는 런타임 비용이 있음

### 동적 변수 사용 줄이기
1. 클래스 인스턴스를 정적으로 만들자
2. 정적 자료구조를 사용하자
3. new 대신 std::make_shared를 사용하자
4. 소유권을 불필요하게 공유하지 말자
5. 동적 변수를 소유하기 위한 소유 포인터를 사용하자

### 동적 변수의 재할당 줄이기
1. 동적 변수를 미리 할당해 재할당을 방지하자
2. 반복문 바깥에서 동적 변수를 만들자.

### 불필요한 복사 제거하기
1. 클래스 정의에서 원치 않는 복사 방지하기
2. 함수 호출에서 복사 제거하기
3. 함수 반환에서 복사 제거하기
4. 복사 없는 라이브러리
5. COW 구현하기

### 이동 문법 구현하기
1. 표준이 아닌 복사 문법 : 고통스러운 핵
2. std::swap() : 가난뱅이의 이동 문법
3. 엔티티의 소유권 공유
4. 이동 문법의 이동 부분
5. 이동 문법을 사용하도록 코드 갱신
6. 이동 문법의 미묘한 부분

### 평평한 자료구조