## 동적 할당 변수 최적화
### C++ 변수
- 모든 C++ 변수는 메모리에 고정된 레이아웃을 가지며 레이아웃의 크기는 **컴파일 타임**에 결정된다.
- 프로그램이 변수의 크기를 바이트 단위로 얻고 그 변수를 가리키는 포인터를 선언하는것을 허용한다.
- 변수의 레이아웃을 비트 단위로 지정하는 것은 허용하지 않는다.

1. 변수의 저장 기간
- 모든 변수는 수명을 갖는다.
- 정적 저장 기간
    - **컴파일러**가 예약해둔 메모리에 상주한다.
    - **고정 메모리 주소**에서 **고정 크기**를 차지한다.
    - 메모리 주소는 **컴파일 타임**에 결정된다.
    - 프로그램이 종료될 때까지 예약되어 있다.
    - 정적 변수를 위한 저장 공간을 생성하는 런타임 비용은 없으나 저장 공간을 재사용할 수는 없다.

- 스레드 지역 저장 기간
    - C=+11 이후 표준으로 작성된 프로그램은 스레드 지역 저장 기간을 갖는 변수를 선언할 수 있다.
    - 스레드에 진입할 때 생성되어 스레드가 끝날 때 파괴된다. (수명은 스레드의 수명과 같다고 할 수 있다.)

- 자동 저장 기간
    - **함수 호출 스택**에서 컴파일러가 예약해둔 메모리에 상주한다.
    - **컴파일 타임**에 메모리 크기가 결정되고, 자동 변수는 각 함수 호출 **스택 포인터**에서 고정된 오프셋 위치를 가진다.
    - 중괄호로 둘러싸인 코드 블록 안에서 존재한다.
    - 선언된 곳에서 생성되어 코드 블록을 빠져나갈 때 파괴된다.
    - 한 번에 사용할 수 있는 **메모리 크기**는 **제한**이 있다.
    - 깊이가 매우 깊은 재귀나 중첩된 함수 호출 때문에 제한된 메모리 크기를 초과하면 **스택 오버플로**가 발생한다.

- 동적 저장 기간
    - 프로그램에서 요청한 메모리에 상주한다.
    - C++ 런타임 시스템 함수와 프로그램 대신 메모리 풀을 관리하는 자료구조로 구성된 **메모리 관리자**를 호출한다.
    - `new`으로 변수를 동적으로 생성한다.
    - `delete`로 변수의 메모리를 메모리 관리자로 반환한다.
    - 동적 변수의 주소는 **런타임**에 결정된다.
    - 소비하는 저장 공간의 크기가 제한되어 있지 않으며 시간에 따라 변할 수 있다.
    - 자동 변수와 달리 동적 변수가 사용하는 메모리를 관리하려면 **런타임 비용**이 많이 필요하다.

2. 변수의 소유권
- 전역 소유권
    - 정적 저장 기간을 갖는 변수는 프로그램이 전체 소유권을 갖는다.
    - `main` 함수에 진입하기 전에 생성되며  `main` 함수를 떠난 뒤 파괴된다.

- 유효 범위가 지정된 소유권
    - 자동 저장 기간을 갖는 변수는 중괄호로 둘러싸인 코드 블록으로 구성된 유효 범위가 소유권을 갖는다.
    - `main` 함수에서 선언된 자동 변수는 정적 변수와 동일한 수명을 갖는다고 볼 수 있다.

- 멤버 소유권
    - 클래스와 구조체의 멤버 변수는 **클래스 인스턴스**가 소유권을 갖는다.
    - 클래스의 인스턴스가 생성될 때 **생성자**로 생성되며 클래스의 인스턴스가 파괴될 때 **소멸자**로 파괴된다.

- 동적 변수의 소유권
    - 동적 변수는 누가 소유권을 갖는지 정의되어 있지 않다.
    - new 표현식이 포인터를 반환하고 이 포인터를 프로그램에서 명시적으로 관리해야 한다.
    - 동적 변수를 가리키는 마지막 포인터가 파괴되기전에 delete 표현식으로 동적 변수를 메모리 관리자에 반환해야 한다.

3. 값 객체와 엔티티 객체
- 값 객체 : 프로그램에서 값을 통해 의미를 얻음
- 값객체의 특징
    1. 값은 서로 교환할 수 있고 **비교**할 수 있다.
    2. 값은 **변경**할 수 없다.
    3. 값은 **복사**할 수 있다.

- 엔티티 : 프로그램에서 역할에 따라 의미를 얻음
- 엔티티의 특징
    1. 엔티티는 유일하다.
        - 프로그램에서 일부 객체는 유일한 정체성을 갖는다.
        - 뮤텍스, 심볼 테이블등이 유일한 정체성을 갖는 객체의 예라고 할 수 있다.
    2. 엔티티는 변경할 수 있다.
        - 프로그램은 뮤텍스에 락을 걸거나 해제할 수 있다. 그래도 동일한 뮤텍스이다.
        - 프록그램은 심볼 테이블에 심볼을 추가할 수 있다. 그래도 심볼 테이블이다.
    3. 엔티티는 **복사**할 수 없다.
    4. 엔티티는 **비교**할 수 없다.
        - 엔티티가 같은지 비교하는 연산은 의미가 없다.
    
- 변수가 엔티티 객체인지 값 객체인지에 따라 복사와 비교 연산이 의미를 갖는지 아닌지가 결정된다.

### C++ 동적 변수 API
1. 스마트 포인터는 동적 변수의 소유권을 자동화함
- 동적 변수의 소유권은 `컴파일러`가 제어하거나 `C++`이 정의하지 않는다.
- 동적 변수의 소유권은 개발자가 정하며 프로그램 로직으로 인코딩한다.
- 개발자는 모든 실행 경로를 추적해 동적 변수를 메모리 관리자에 제대로 반환하는지 확인해야 한다.
- 한가지 방법으로는 포인터 변수를 어떤 클래스의 private 멤버로 선언하는 것이다.
    - 클래스의 생성자에서 포인터를 `nullptr`로 설정하거나 동적 변수를 생성하는 `new 표현식`을 포함할 수 있다.
    - 클래스의 소멸자는 동적 변수를 파괴하는 `delete 표현식`을 포함할 수 있다.
    - 포인터에 영향을 주는 곳이 제한되어 코딩, 디버깅이 수월해진다.
- C++은 T 타입을 갖는 동적 변수의 소유권을 유지하기 위해 `std::unique_ptr`라는 스마트 포인터 템플릿을 제공한다.
    - `unique_ptr`은 효율적인 측면에서 직접 작성한 코드와 필적할 만한 코드로 컴파일 한다.

- 동적 변수의 소유권 자동화
    - **스마트 포인터**는 동적 변수의 **소유권을 자동화**해 동적 변수의 수명과 동적 변수를 소유하는 스마트 포인터의 수명을 연결한다.
    - **자동 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 `break` 문이나 `continue`문 등의 선언문을 둘러 싸고 있는 범위를 빠져나갈 떄 소유한 동적 변수를 삭제한다.
    - **클래스 멤버**로 선언된 스마트 포인터의 인스턴스는 스마트 포인터를 포함하는 **클래스 인스턴스가 파괴**될 때 소유한 동적 변수를 삭제한다.
    - **스레드 지역 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **스레드가 정상적으로 종료**될 때 소유한 동적 변수를 삭제한다.
    - **정적 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **프로그램이 종료**될 떄 소유한 동적 변수를 삭제한다.

- 동적 변수의 소유권을 공유하면 비용이 더 크다.
    - C++은 **여러 개**의 포인터와 참조가 **하나**의 동적 변수를 가리키는 것을 허용한다.
    - 여러 자료구조가 특정 동적 변수를 가리킨다면, 두 개 이상의 포인터가 하나의 동적 변수를 가리킨다.
    - 개발자는 어떤 포인터가 동적 변수의 소유자인지 판단해야 한다.
    - 소유권을 공유해야 하는 경우 관리할 수 있는 `std::shared_ptr` 을 제공한다.
        - `shared_ptr`의 인스턴스는 동적 변수를 가리키는 포인터와 참조 수를 가지는 동적 객체를 가리키는 또 다른 포인터를 포함한다.
        - `shared_ptr`에 대입하면 참조 수를 1 증가시키고 `shared_ptr`이 파괴되면 소멸자로 참조 수를 1 감소시키고 참조 수가 0이 되면 동적 변수를 삭제한다.

- `std::auto_ptr` 대 컨테이너 클래스
    - `std::auto_ptr`은 공유되지 않은 동적 변수의 소유권도 관리할 수 있다.
        - `auto_ptr`의 작동 방법은 `unique_ptr`와 비슷하다.
        - `auto_ptr` 은 이동 문법을 구현하지 않으며 복사 생성자가 없다.

2. 동적 변수는 런타임 비용이 있음
- 메모리를 할당하는 함수는 요청한 메모리 블록을 할당하려고 **빈 메모리 블록**의 컬렉션을 찾는다.
    - 함수가 빈 메모리 블록을 찾으면 컬렉션에서 블록을 제거한 뒤 반환한다.
    - 함수가 메모리 블록을 요청했을 때 이용 가능한 메모리 블록이 없으면, 할당 함수는 큰 메모리 블록을 추가로 얻기 위해서 가용 메모리 시스템 풀에서 운영체제 커널을 **고비용**으로 호출한다.
    - 캐시되어 있지 않다면, 해당 메모리 영역에 처음 접근할 때는 더 많이 지연될 수 있다.

### 동적 변수 사용 줄이기
1. 클래스 인스턴스를 정적으로 만들자
- 컨테이너의 일부가 아닌 대부분의 클래스 인스턴스는 **정적**으로 만들어야 한다.
- **정적**으로 만든다면 **자동 저장 기간**을 갖고 선언문을 포함하는 블록을 빠져나갈때 파괴된다.
- 수명을 연장하고 싶으면 더 바깥에 있는 범위나 수명이 긴 객체 안에 선언 후 **포인터를 전달**한다.
- 프로그램이 종료될 때까지 살아 있어야 한다면 선언문을 **파일 범위**로 옮긴다.

2. **정적 자료구조**를 사용하자
- `std::vector` 대신 `std:array` 사용하기
    - 배열의 크기가 고정되었거나, 사용할 최대 크기를 컴파일 타임에 알 수 있다면 `std::array`를 쓰는게 좋다.
- 스택에 큰 버퍼를 만들기
- 연결 자료구조를 정적으로 만들기
- 이진트리를 배열로 만들기
- `Deque` 대신 원형 버퍼 사용하기

3. new 대신 std::make_shared를 사용하자
- `std::shared_ptr`과 같은 공유 포인터는 실제로 두 포인터를 포함한다.
    1. 포인터로 참조된 객체
    2. 동일한 객체를 참조하는 모든 `std::shared_ptr`의 참조 수를 저장하는 동적 변수
- `std::shared_ptr<MyClass> p = std::make_shared<MyClass>("Hello", 123);`

4. 소유권을 불필요하게 공유하지 말자
- `std::shared_ptr` 타입의 여러 인스턴스는 동적 변수의 소유권을 공유할 수 있다.
- `std::shared_ptr`에서 참조 수를 증가 및 감소시키면 단순히 증감 명령을 수행하는게 아니라 메모리 진입 장벽 기법을 이용하여 명령 수행 도중 절대 방해받지 않는 비용이 아주 큰 단위 명령을 수행한다.
- 어떤 `shared_ptr`의 **수명**이 다른 `shared_ptr`의 수명을 포함한다면 두번째 `shared_ptr`의 비용은 불필요 하므로 둘중 하나를 일반 포인터로 바꿔주는게 좋다.

5. 동적 변수를 소유하기 위한 소유 포인터를 사용하자
- `std::shared_ptr`은 동적 변수의 관리를 자동화 하지만 비용이 많이 든다.
- 동적 변수를 가리키는 참조나 포인터는 **함수로 전달**하거나, **함수에서 반환**되거나, **변수에 할당**될 수 있지만 소유 참조보다 **수명이 긴 참조는 없다**.
- 소유 참조가 있다면 `std::unique_ptr`을 사용해 효율적으로 구현할 수 있다.

### 동적 변수의 재할당 줄이기
- 동적 변수를 사용할때는 할당 횟수를 줄일수 있도록 노력해야 한다.

1. 동적 변수를 미리 할당해 재할당을 방지하자
- `std::string`이나 `std::vector`에 데이터를 추가하다 보면 동적 할당 내부 저장 공간이 가득 찬다.
- `reserve()`라는 함수를 통해 인자로 `size_t`타입의 인자 n을 넣으면 적어도 n개의 항목을 저장할 수 있는 공간을 확보할 수 있다.
- **크기를 계산하거나 추정**할 수 있다면 `reserve()`함수를 호출해 문자열이나 벡터의 내부 저장공간을 확보하는게 좋다.
- 사용자 정의 자료구조를 설계할 때, 배열을 미리 할당해 주는 `reserve()`와 같은 함수를 만들어 편의를 제공해야 한다.

2. 반복문 바깥에서 동적 변수를 만들자.
- 반복문 안에 `std::string`같은 타입의 변수 선언을 넣게 되면 매번 동적 할당을 하게 된다.
- 변수 선언을 반복문 밖으로 뺀 후 반복문에서는 해당 변수를 `clear()`함수를 사용한다.
    - `clear()`함수는 문자열의 길이를 0으로 설정한다.
    - 반복문을 처음 실행한 뒤 다음으로 `std::string`에 저장할 값이 매우 길지 않다면 해당 값은 재할당 되지 않는다.

### 불필요한 복사 제거하기
- 최적화할 곳을 찾으려고 실행이 잦은 코드를 조사하는 개발자는 **대입**과 **선언**에 특별한 주의를 기울여야 한다.
- 다음과 같은 위치에 복사연산이 있을 가능성이 존재한다.
    - 초기화
    - 대입
    - 함수 인수
    - 함수 반환
    - 표준 라이브러리 컨테이너에 항목을 삽입
    - 벡터에 항목을 삽입

1. 클래스 정의에서 원치 않는 복사 방지하기
- 프로그램에 있는 모든 객체를 복사할 필요는 없다.
- 클래스 인스턴스를 복사하는 비용이 많거나 복사를 원하지 않는다면 비용이 생기지 않도록 복사를 금지하는 방법이 있다.
    - **복사 생성자**와 **대입 연산자**를 `private`로 선언하면 호출되지 않게 만들 수 있다.
    - C++11에서는 **복사 생성자**와 **대입 연산자**의 선언에 `delete` 키워드를 추가하면 동일한 결과를 얻을 수 있다. 이 경우에는 삭제된 생성자를 `public`으로 선언하는게 좋다.

2. 함수 호출에서 복사 제거하기
- 함수의 인자가 `int`, `double`과 같은 기본 타입이라면 생성자는 개념적으로 존재할 뿐 실제로 함수가 있지는 않다.
- 함수의 인자가 `std::list`라면 복사 생성자는 새 항목을 만들려고 메모리 관리자를 호출하게 된다.
- 인자가 100만개의 항목을 저장하는 `std::list`라면 100만번의 호출이 발생한다.
- 이 비용을 피하기 위해
    - 형식 인수를 아무것도 하지 않는 **복사 생성자**를 갖는 타입으로 정의할 수 있다.
    - 인스턴스를 복사 생성하는 대신 실제 인수를 가리키는 **참조**로 초기화 하는 것이다.

3. 함수 반환에서 복사 제거하기
- 함수가 값을 반환하면 반환 타입과 동일한 익명의 임시 변수가 반환값으로 복사 생성 된다.
- `int`, `double`과 같은 기본 타입이 아닌 클래스라면 **복사 생성자**는 일반적으로 실제 함수를 호출하게 된다.
- 컴파일러가 복사 생략 또는 반환값 최적화(RVO)를 실행하기도 하지만 RVO를 수행할 수 있는 조건은 매우 구체적이다.

4. 복사 없는 라이브러리
5. COW 구현하기

### 이동 문법 구현하기
1. 표준이 아닌 복사 문법 : 고통스러운 핵
2. std::swap() : 가난뱅이의 이동 문법
3. 엔티티의 소유권 공유
4. 이동 문법의 이동 부분
5. 이동 문법을 사용하도록 코드 갱신
6. 이동 문법의 미묘한 부분

### 평평한 자료구조