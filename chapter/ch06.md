## 동적 할당 변수 최적화
### C++ 변수
- 모든 C++ 변수는 메모리에 고정된 레이아웃을 가지며 레이아웃의 크기는 **컴파일 타임**에 결정된다.
- 프로그램이 변수의 크기를 바이트 단위로 얻고 그 변수를 가리키는 포인터를 선언하는것을 허용한다.
- 변수의 레이아웃을 비트 단위로 지정하는 것은 허용하지 않는다.

1. 변수의 저장 기간
- 모든 변수는 수명을 갖는다.
- 정적 저장 기간
    - **컴파일러**가 예약해둔 메모리에 상주한다.
    - **고정 메모리 주소**에서 **고정 크기**를 차지한다.
    - 메모리 주소는 **컴파일 타임**에 결정된다.
    - 프로그램이 종료될 때까지 예약되어 있다.
    - 정적 변수를 위한 저장 공간을 생성하는 런타임 비용은 없으나 저장 공간을 재사용할 수는 없다.

- 스레드 지역 저장 기간
    - C=+11 이후 표준으로 작성된 프로그램은 스레드 지역 저장 기간을 갖는 변수를 선언할 수 있다.
    - 스레드에 진입할 때 생성되어 스레드가 끝날 때 파괴된다. (수명은 스레드의 수명과 같다고 할 수 있다.)

- 자동 저장 기간
    - **함수 호출 스택**에서 컴파일러가 예약해둔 메모리에 상주한다.
    - **컴파일 타임**에 메모리 크기가 결정되고, 자동 변수는 각 함수 호출 **스택 포인터**에서 고정된 오프셋 위치를 가진다.
    - 중괄호로 둘러싸인 코드 블록 안에서 존재한다.
    - 선언된 곳에서 생성되어 코드 블록을 빠져나갈 때 파괴된다.
    - 한 번에 사용할 수 있는 **메모리 크기**는 **제한**이 있다.
    - 깊이가 매우 깊은 재귀나 중첩된 함수 호출 때문에 제한된 메모리 크기를 초과하면 **스택 오버플로**가 발생한다.

- 동적 저장 기간
    - 프로그램에서 요청한 메모리에 상주한다.
    - C++ 런타임 시스템 함수와 프로그램 대신 메모리 풀을 관리하는 자료구조로 구성된 **메모리 관리자**를 호출한다.
    - `new`으로 변수를 동적으로 생성한다.
    - `delete`로 변수의 메모리를 메모리 관리자로 반환한다.
    - 동적 변수의 주소는 **런타임**에 결정된다.
    - 소비하는 저장 공간의 크기가 제한되어 있지 않으며 시간에 따라 변할 수 있다.
    - 자동 변수와 달리 동적 변수가 사용하는 메모리를 관리하려면 **런타임 비용**이 많이 필요하다.

2. 변수의 소유권
- 전역 소유권
    - 정적 저장 기간을 갖는 변수는 프로그램이 전체 소유권을 갖는다.
    - `main` 함수에 진입하기 전에 생성되며  `main` 함수를 떠난 뒤 파괴된다.

- 유효 범위가 지정된 소유권
    - 자동 저장 기간을 갖는 변수는 중괄호로 둘러싸인 코드 블록으로 구성된 유효 범위가 소유권을 갖는다.
    - `main` 함수에서 선언된 자동 변수는 정적 변수와 동일한 수명을 갖는다고 볼 수 있다.

- 멤버 소유권
    - 클래스와 구조체의 멤버 변수는 **클래스 인스턴스**가 소유권을 갖는다.
    - 클래스의 인스턴스가 생성될 때 **생성자**로 생성되며 클래스의 인스턴스가 파괴될 때 **소멸자**로 파괴된다.

- 동적 변수의 소유권
    - 동적 변수는 누가 소유권을 갖는지 정의되어 있지 않다.
    - new 표현식이 포인터를 반환하고 이 포인터를 프로그램에서 명시적으로 관리해야 한다.
    - 동적 변수를 가리키는 마지막 포인터가 파괴되기전에 delete 표현식으로 동적 변수를 메모리 관리자에 반환해야 한다.

3. 값 객체와 엔티티 객체
- 값 객체 : 프로그램에서 값을 통해 의미를 얻음
- 값객체의 특징
    1. 값은 서로 교환할 수 있고 **비교**할 수 있다.
    2. 값은 **변경**할 수 없다.
    3. 값은 **복사**할 수 있다.

- 엔티티 : 프로그램에서 역할에 따라 의미를 얻음
- 엔티티의 특징
    1. 엔티티는 유일하다.
        - 프로그램에서 일부 객체는 유일한 정체성을 갖는다.
        - 뮤텍스, 심볼 테이블등이 유일한 정체성을 갖는 객체의 예라고 할 수 있다.
    2. 엔티티는 변경할 수 있다.
        - 프로그램은 뮤텍스에 락을 걸거나 해제할 수 있다. 그래도 동일한 뮤텍스이다.
        - 프록그램은 심볼 테이블에 심볼을 추가할 수 있다. 그래도 심볼 테이블이다.
    3. 엔티티는 **복사**할 수 없다.
    4. 엔티티는 **비교**할 수 없다.
        - 엔티티가 같은지 비교하는 연산은 의미가 없다.
    
- 변수가 엔티티 객체인지 값 객체인지에 따라 복사와 비교 연산이 의미를 갖는지 아닌지가 결정된다.

### C++ 동적 변수 API
1. 스마트 포인터는 동적 변수의 소유권을 자동화함
- 동적 변수의 소유권은 `컴파일러`가 제어하거나 `C++`이 정의하지 않는다.
- 동적 변수의 소유권은 개발자가 정하며 프로그램 로직으로 인코딩한다.
- 개발자는 모든 실행 경로를 추적해 동적 변수를 메모리 관리자에 제대로 반환하는지 확인해야 한다.
- 한가지 방법으로는 포인터 변수를 어떤 클래스의 private 멤버로 선언하는 것이다.
    - 클래스의 생성자에서 포인터를 `nullptr`로 설정하거나 동적 변수를 생성하는 `new 표현식`을 포함할 수 있다.
    - 클래스의 소멸자는 동적 변수를 파괴하는 `delete 표현식`을 포함할 수 있다.
    - 포인터에 영향을 주는 곳이 제한되어 코딩, 디버깅이 수월해진다.
- C++은 T 타입을 갖는 동적 변수의 소유권을 유지하기 위해 `std::unique_ptr`라는 스마트 포인터 템플릿을 제공한다.
    - `unique_ptr`은 효율적인 측면에서 직접 작성한 코드와 필적할 만한 코드로 컴파일 한다.

- 동적 변수의 소유권 자동화
    - **스마트 포인터**는 동적 변수의 **소유권을 자동화**해 동적 변수의 수명과 동적 변수를 소유하는 스마트 포인터의 수명을 연결한다.
    - **자동 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 `break` 문이나 `continue`문 등의 선언문을 둘러 싸고 있는 범위를 빠져나갈 떄 소유한 동적 변수를 삭제한다.
    - **클래스 멤버**로 선언된 스마트 포인터의 인스턴스는 스마트 포인터를 포함하는 **클래스 인스턴스가 파괴**될 때 소유한 동적 변수를 삭제한다.
    - **스레드 지역 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **스레드가 정상적으로 종료**될 때 소유한 동적 변수를 삭제한다.
    - **정적 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **프로그램이 종료**될 떄 소유한 동적 변수를 삭제한다.

- 동적 변수의 소유권을 공유하면 비용이 더 크다.
    - C++은 **여러 개**의 포인터와 참조가 **하나**의 동적 변수를 가리키는 것을 허용한다.
    - 여러 자료구조가 특정 동적 변수를 가리킨다면, 두 개 이상의 포인터가 하나의 동적 변수를 가리킨다.
    - 개발자는 어떤 포인터가 동적 변수의 소유자인지 판단해야 한다.
    - 소유권을 공유해야 하는 경우 관리할 수 있는 `std::shared_ptr` 을 제공한다.
        - `shared_ptr`의 인스턴스는 동적 변수를 가리키는 포인터와 참조 수를 가지는 동적 객체를 가리키는 또 다른 포인터를 포함한다.
        - `shared_ptr`에 대입하면 참조 수를 1 증가시키고 `shared_ptr`이 파괴되면 소멸자로 참조 수를 1 감소시키고 참조 수가 0이 되면 동적 변수를 삭제한다.

- `std::auto_ptr` 대 컨테이너 클래스
    - `std::auto_ptr`은 공유되지 않은 동적 변수의 소유권도 관리할 수 있다.
        - `auto_ptr`의 작동 방법은 unique_ptr와 비슷하다.
        - `auto_ptr` 은 이동 문법을 구현하지 않으며 복사 생성자가 없다.

2. 동적 변수는 런타임 비용이 있음

### 동적 변수 사용 줄이기
1. 클래스 인스턴스를 정적으로 만들자
2. 정적 자료구조를 사용하자
3. new 대신 std::make_shared를 사용하자
4. 소유권을 불필요하게 공유하지 말자
5. 동적 변수를 소유하기 위한 소유 포인터를 사용하자

### 동적 변수의 재할당 줄이기
1. 동적 변수를 미리 할당해 재할당을 방지하자
2. 반복문 바깥에서 동적 변수를 만들자.

### 불필요한 복사 제거하기
1. 클래스 정의에서 원치 않는 복사 방지하기
2. 함수 호출에서 복사 제거하기
3. 함수 반환에서 복사 제거하기
4. 복사 없는 라이브러리
5. COW 구현하기

### 이동 문법 구현하기
1. 표준이 아닌 복사 문법 : 고통스러운 핵
2. std::swap() : 가난뱅이의 이동 문법
3. 엔티티의 소유권 공유
4. 이동 문법의 이동 부분
5. 이동 문법을 사용하도록 코드 갱신
6. 이동 문법의 미묘한 부분

### 평평한 자료구조