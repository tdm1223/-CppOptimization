# Chapter9 검색 및 정렬 최적화
## 9.1 std::map과 std::string을 사용한 키/값 테이블
- 일반적인 키/값 테이블을 검색하고 정렬할 때의 성능을 살펴본다.
- 키타입은 `ASCII` 문자열로 `C++` 문자열 리터럴로 초기화되거나 `std::string`에 저장된다.
- 값타입은 **검색 성능**에 영향을 미치지 않는다.
  - 엄청 큰 값일 경우 캐시 성능을 저하시킬수 있다.
  - 단순한 값 타입을 사용했을 때 성능이 더 좋으므로 여기에서는 **부호가 없는 정수**를 사용한다.
- `std::map`을 사용하면 `std::string`타입을 갖는 이름을 값으로 매핑하는 테이블을 손쉽게 만들 수 있다.
```cpp
std::map<std::string, unsigned> const table;
```
- C++11 컴파일러를 사용할 경우 이니셜 라이저 문법을 사용해 초기화 할수 있다.
```cpp
std::map<std::string, unsigned> const table{
    {"alpha", 1}, {"bravo", 2},{"charlie", 3}, {"delta", 4}
};
```
- 이니셜 라이저 문법을 사용하지 않으면 각 요소를 삽입해야 한다.
```cpp
std::map<std::string, unsigned> table;
table["alpha"] = 1;
table["bravo"] = 2;
table["charlie"] = 3;
table["delta"] = 4;
```
- 간단히 값을 검색하거나 테스트 할 수 있다.
```cpp
unsigned val = table["echo"];
std::string key = "diamond";
if (table.find(key) != table.end())
{
  std::cout << "table contains " << key << std::endl;
}
```
- `std::map`으로 테이블을 만드는 코드는 C++ 표준 라이브러리가 얼마나 **강력한 추상화**를 제공하는지 보여준다.
  - 시간을 **최소한**으로 줄이면서 **합리적인 성능**을 달성할 수 있다.

## 9.2 검색 성능 향상을 위한 툴킷
#### 테이블을 검색하는 코드를 포함한 함수가 프로그램에서 가장 많이 실행되는 함수라면?
```cpp
void HotFunction(std::string const& key)
{
    auto it = table.find(key);
    if (it == table.end())
    {
        // 테이블에 항목이 없을 때 행동
    }
    else
    {
        // 테이블에 항목이 있을 때 행동
    }
}
```
- 이보다 더 좋은 코드를 구현할수 있을까? 아래와 같이 체계적으로 진행하는 것이 좋다.
  1. 기존 구현 코드의 성능을 측정하고 비교하기 위한 **기준치**를 얻는다.
  2. 최적화할 ***추상화 코드***를 확인한다.
  3. 최적화할 코드를 **알고리즘**과 **자료구조**로 분해한다.
  4. 최적이 아닌 **알고리즘**과 **자료구조**를 변경하거나 바꾼다. 변경한 코드가 효과적인지 실험한다.

### 9.2.1 측정 기준치를 만드세요
- [챕터 3.2.2 내용](/Chapter/Chapter3.md)처럼 최적화되지 않은 코드의 성능을 측정해서 최적화한 코드를 **테스트하기 위한 측정 기준치**를 얻어야 한다.

### 9.2.2 최적화할 코드를 확인하세요
- 최적화할 코드를 확인해 여러 조각으로 분해하고 최적화 후보듣 더 쉽게 찾을수 있도록 만드는 단계이다.
- 최적화할 코드는 개발자 입장에서 판단해야 한다.
- **많이 실행되는 코드**를 통해 최적화할 코드를 찾아 볼 수 있다.
- 기본 구현 코드에서 문제 설명에 얽매이지 않기 위해 **추상적으로 문제를 작성**한다.
  - 위 예제의 경우 **키/값 테이블에서 텍스트 키로 값을 검색하는 문제**로 작성할 수 있다.

### 9.2.3 최적화할 코드를 분해하세요
- 최적화할 코드를 **알고리즘**과 **자료구조**로 분해한다.
- 최적화할 코드는 **텍스트 키가 있는 키/값 테이블에서 값을 검색**하는 코드이다.
- 기본 해결책을 구성하는 알고리즘과 자료구조는 재사용할 수 있다.
- 기존 해결책으로 사고 방법을 제한하지 않고 일반화해 알고리즘과 자료구조를 설명하는 것이 중요하다.

#### 최적화할 코드 점검
- 기본 해결책에서 테이블은 `std::map`이다.
- 기본 해결책에서 키는 `std::string`의 인스턴스이다.
- `std::map`의 템플릿 정의는 로직이 일부 있지만 [키를 비교하는 함수를 지정할 수 있는 매개변수](https://en.cppreference.com/w/cpp/container/map)를 제공한다.(3번째 인자)
- 많이 실행되는 함수는 `operator[]`를 사용하지 않고 `std::map::find()`함수를 호출한다.
- `std::map`은 **균형 이진 트리**로 구현되어 있으므로 각 노드를 생성해야 하는 **연결 리스트 기반 자료구조**이다.
  - 삽입 알고리즘이 있어야 하고 삽입시 비용이 많이 든다.

### 9.2.4 알고리즘과 자료구조를 변경하거나 바꾸세요
 - 기존 해결책에서 **최적이 아닌 알고리즘**을 찾는다.
  - 자료구조에서 최적화할 필요가 없거나 비용이 많이 드는 작동을 찾아 제거하거나 단순하게 만들 수 있다.
 - `std::map`은 균형 이진 트리로 구현되어 있어 검색 시간 복잡도는 `O(logn)`이다.
  - **검색시간 비용이 낮은 자료구조**로 바꿀 수 있다면 성능이 개선될 것이다.
 - `std::map`은 노드 기반 자료구조를 사용한다.
  - 생성 과정에서 **메모리 관리자를 자주 호출**해 **캐시 지역성**이 좋지 않다.
  - 최적화할 코드에서 항목은 테이블을 생성하는 과정에서만 삽입되고 테이블이 존재하는 동안에는 삭제되지 않는다.
- 키 자료구조에 필요한 기능은 **문자를 포함**하는 기능과 **두 키를 비교**하는 기능이다.
  - `std::string`은 두 가지 기능 외에 불필요한 더 많은 기능을 제공한다.