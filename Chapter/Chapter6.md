# Chapter6 동적 할당 변수 최적화
- 메모리 관리자의 호출 횟수를 줄이는 방법을 알고 있다면 효과적으로 최적화 할 수 있다.
- 메모리 관리자를 불필요하게 호출해 성능을 저하하는 요인을 제거한다.

## 6.1 C++ 변수
- 모든 C++ 변수는 메모리에 고정된 레이아웃을 가지며 레이아웃의 크기는 **컴파일 타임**에 결정된다.
- C++은 프로그램이 변수의 크기를 바이트 단위로 얻고 그 변수를 가리키는 포인터를 선언하는것을 허용한다.
  - 변수의 레이아웃을 비트 단위로 지정하는 것은 허용하지 않는다.

### 6.1.1 변수의 저장 기간
- 모든 변수는 저장 기간(수명)을 갖는다.
  - 저장 기간이란 변수가 차지하는 저장 공간이나 메모리 바이트가 의미있는 값을 갖는 기간을 말한다.

#### 정적 저장 기간
- **컴파일러**가 예약해둔 메모리에 상주한다.
- **고정 메모리 주소**에서 **고정 크기**를 차지한다.
- 메모리 주소는 **컴파일 타임**에 결정된다.
- 프로그램이 종료될 때까지 예약되어 있다.
- 각 전역 정적 변수는 `main` 함수에 진입하기 전에 생성되며 `main` 함수를 떠난 뒤 파괴된다.
- 정적 변수를 위한 저장 공간을 생성하는 런타임 비용은 없으나 저장 공간을 재사용할 수는 없다.

#### 스레드 지역 저장 기간
- `C++11` 이후 표준으로 작성된 프로그램은 스레드 지역 저장 기간을 갖는 변수를 선언할 수 있다.
- 스레드에 진입할 때 생성되어 스레드가 끝날 때 파괴된다. (수명은 스레드의 수명과 같다고 할 수 있다.)
- 각 스레드는 스레드 지역 변수의 복사본을 갖는다.
- 스레드 지역 변수에 접근하는 비용은 운영체제와 컴파일러에 따라 다르겠지만 정적 변수에 접근하는 비용보다 더 높을 수 있다.
- `C++11` 에서 `thread_local` 키워드로 선언된 변수는 스레드 지역 저장 기간을 갖는다.

#### 자동 저장 기간
- **함수 호출 스택**에서 컴파일러가 예약해둔 메모리에 상주한다.
- **컴파일 타임**에 메모리 크기가 결정되고 자동 변수는 각 함수 호출 **스택 포인터**에서 고정된 오프셋 위치를 가진다.
- 중괄호로 둘러싸인 코드 블록 안에서 존재한다.
- 선언된 곳에서 생성되어 코드 블록을 **빠져나갈 때 파괴**된다.
- 한 번에 사용할 수 있는 **메모리 크기**는 **제한**이 있다.
- 깊이가 매우 깊은 재귀나 중첩된 함수 호출 때문에 제한된 메모리 크기를 초과하면 **스택 오버플로**가 발생한다.
- 함수의 인수 형태로 선언된 변수는 자동 저장 기간을 갖는다.

#### 동적 저장 기간
- 프로그램에서 **요청한 메모리에 상주**한다.
- `C++` 런타임 시스템 함수와 프로그램 대신 메모리 풀을 관리하는 자료구조로 구성된 **메모리 관리자**를 호출한다.
- `new`으로 변수를 동적으로 생성한다.
  - `new` 표현식으로 반환된 변수는 동적 저장 기간을 갖는다.
- `delete`로 변수의 메모리를 메모리 관리자로 반환한다.
- 동적 변수의 주소는 **런타임**에 결정된다.
- 소비하는 저장 공간의 크기가 제한되어 있지 않으며 시간에 따라 변할 수 있다.
- 자동 변수와 달리 동적 변수가 사용하는 메모리를 관리하려면 **런타임 비용**이 많이 필요하다.

### 6.1.2 변수의 소유권
- 변수의 주인은 변수가 생성될 때 와 파괴될 때는 결정한다.

#### 전역 소유권
- 정적 저장 기간을 갖는 변수는 **프로그램**이 전체 소유권을 갖는다.
- `main` 함수에 진입하기 전에 생성되며 `main` 함수를 떠난 뒤 파괴된다.

#### 유효 범위가 지정된 소유권
- 자동 저장 기간을 갖는 변수는 **중괄호로 둘러싸인 코드 블록으로 구성된 유효 범위**가 소유권을 갖는다.
- `main` 함수에서 선언된 자동 변수는 정적 변수와 동일한 수명을 갖는다고 볼 수 있다.

#### 멤버 소유권
- 클래스와 구조체의 멤버 변수는 **클래스 인스턴스**가 소유권을 갖는다.
- 클래스의 인스턴스가 생성될 때 **생성자**로 생성되며 클래스의 인스턴스가 파괴될 때 **소멸자**로 파괴된다.

#### 동적 변수의 소유권
- 동적 변수는 누가 소유권을 갖는지 정의되어 있지 않다.
- `new` 표현식이 포인터를 반환하고 이 포인터를 프로그램에서 명시적으로 관리해야 한다.
- 동적 변수를 가리키는 마지막 포인터가 파괴되기전에 `delete` 표현식으로 동적 변수를 메모리 관리자에 반환해야 한다.

### 6.1.3 값 객체와 엔티티 객체
#### 값 객체
- 프로그램에서 값을 통해 의미를 얻는 변수

#### 값은 서로 교환할 수 있고 비교할 수 있습니다
- 값의 의미는 비트에서 나온 것이지 사용하는 방법에서 나온 것이 아니다.

#### 값은 변경할 수 없습니다
- 값을 4에서 5로 변경해 2 + 2 = 5 로 만드는 연산은 없다.
- 4를 저장하는 정수 타입 변수에 5를 저장하도록 변경할 수는 있다.
  - 유일한 이름을 갖는 엔티티인 변수를 변경하는 것이지 값 4를 변경하는 것이 아니다.

#### 값은 복사할 수 있습니다
- 두개의 문자열 변수에 같은 `HELLO WORLD`라는 값을 지정해도 프로그램은 잘 동작한다.

#### 엔티티
- 프로그램에서 역할에 따라 의미를 얻는 변수

#### 엔티티는 유일합니다
- 프로그램에서 일부 객체는 유일한 정체성을 갖는다.
- 뮤텍스, 심볼 테이블등이 유일한 정체성을 갖는 객체의 예라고 할 수 있다.

#### 엔티티는 변경할 수 있습니다
- 프로그램은 뮤텍스에 락을 걸거나 해제할 수 있다. 그래도 동일한 뮤텍스이다.
- 프록그램은 심볼 테이블에 심볼을 추가할 수 있다. 그래도 심볼 테이블이다.
- 엔티티는 전체로서 의미를 갖는다.
  - 엔티티의 상태를 변경해도 프로그램에서의 근본적인 의미는 변하지 않는다.

#### 엔티티는 복사할 수 없습니다
- 엔티티의 본질은 사용하는 방법에서 나온 것이지 비트에서 나온것이 아니다.
- 시스템 심볼 테이블의 모든 비트를 다른 자료구조로 복사한다고 해서 그 자료구조가 심볼 테이블이 되지는 않는다.

#### 엔티티는 비교할 수 없습니다
- 엔티티가 같은지 비교하는 연산은 의미가 없다.
- 엔티티는 본질적으로 모두 다르다.

## 6.2 C++ 동적 변수 API
### 6.2.1 스마트 포인터는 동적 변수의 소유권을 자동화합니다
- 동적 변수의 소유권은 `컴파일러`가 제어하거나 `C++`이 정의하지 않는다.
- 동적 변수의 소유권은 개발자가 정하며 프로그램 로직으로 인코딩한다.
- 개발자는 모든 실행 경로를 추적해 동적 변수를 메모리 관리자에 제대로 반환하는지 확인해야 한다.
- 한가지 방법으로는 포인터 변수를 클래스의 `private` 멤버로 선언하는 것이다.
    - 클래스의 생성자에서 포인터를 `nullptr`로 설정하거나 동적 변수를 생성하는 `new 표현식`을 포함할 수 있다.
    - 클래스의 소멸자는 동적 변수를 파괴하는 `delete 표현식`을 포함할 수 있다.
    - 포인터에 영향을 주는 곳이 제한되어 코딩, 디버깅이 수월해진다.
- `C++`은 동적 변수의 소유권을 유지하기 위해 `std::unique_ptr`라는 스마트 포인터 템플릿을 제공한다.
    - `unique_ptr`은 효율적인 측면에서 직접 작성한 코드와 필적할 만한 코드로 컴파일 한다.

#### 동적 변수의 소유권 자동화
- **스마트 포인터**는 동적 변수의 **소유권을 자동화**해 동적 변수의 수명과 동적 변수를 소유하는 스마트 포인터의 수명을 연결한다.
- **자동 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 `break` 문이나 `continue`문 등의 선언문을 둘러 싸고 있는 범위를 빠져나갈 떄 소유한 동적 변수를 삭제한다.
- **클래스 멤버**로 선언된 스마트 포인터의 인스턴스는 스마트 포인터를 포함하는 **클래스 인스턴스가 파괴**될 때 소유한 동적 변수를 삭제한다.
- **스레드 지역 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **스레드가 정상적으로 종료**될 때 소유한 동적 변수를 삭제한다.
- **정적 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **프로그램이 종료**될 떄 소유한 동적 변수를 삭제한다.

#### 동적 변수의 소유권을 공유하면 비용이 더 큽니다
- C++은 **여러 개**의 포인터와 참조가 **하나**의 동적 변수를 가리키는 것을 허용한다.
  - 여러 자료구조가 특정 동적 변수를 가리킨다면 두 개 이상의 포인터가 하나의 동적 변수를 가리킨다.
- 개발자는 어떤 포인터가 동적 변수의 소유자인지 판단해야 한다.
- 소유권을 공유해야 하는 경우 관리할 수 있는 `std::shared_ptr` 을 제공한다.
  - `shared_ptr`의 인스턴스는 동적 변수를 가리키는 포인터와 참조 수를 가지는 동적 객체를 가리키는 또 다른 포인터를 포함한다.
  - `shared_ptr`에 대입하면 참조 수를 1 증가시키고 `shared_ptr`이 파괴되면 소멸자로 참조 수를 1 감소시키고 참조 수가 0이 되면 동적 변수를 삭제한다.

#### std::auto_ptr 대 컨테이너 클래스
- `std::auto_ptr`은 공유되지 않은 동적 변수의 소유권도 관리할 수 있다.
  - `auto_ptr`의 작동 방법은 `unique_ptr`와 비슷하다.
  - `auto_ptr` 은 이동 문법을 구현하지 않으며 복사 생성자가 없다.

### 6.2.2 동적 변수는 런타임 비용이 있습니다
- C++은 기계어로 컴파일된 후 컴퓨터에서 바로 실행되기 때문에 `C++`문장의 비용 대부분은 몇 번의 메모리 접근이 전부이다.
  - 동적 변수의 메모리를 할당하기 위해 수천 번의 메모리 접근이 필요하다.
  - 메모리 관리자를 호출하는 횟수를 한 번만 줄여도 함수의 성능이 크게 향상된다.
- 함수가 메모리 블록을 요청했을 때 이용가능한 메모리 블록이 없다면?
  - 할당 함수는 큰 메모리 블록을 추가로 얻기 위해 가용 메모리 시스템 풀에서 운영체제 커널을 **고비용**으로 호출한다.
  - 메모리가 물리적 `RAM`에 캐시되어 있지 않다면 해당 메모리 영역에 처음 접근할 때는 더 많이 지연될 수 있다.
- 메모리를 할당하는 함수는 요청한 메모리 블록을 할당하려고 **빈 메모리 블록**의 컬렉션을 찾는다.
  - 함수가 빈 메모리 블록을 찾으면 컬렉션에서 블록을 제거한 뒤 반환한다.

## 6.3 동적 변수 사용 줄이기
- 동적 변수를 사용하면 수많은 문제를 해결할 수 있다.
- 모든 문제를 해결하기에는 비용이 너무 크다는 단점이 있다.
- 정적으로 만든 변수는 종종 동적 변수의 작업을 대신 수행할 수 있다.

### 6.3.1 클래스 인스턴스를 정적으로 만드세요
- 컨테이너의 일부가 아닌 대부분의 클래스 인스턴스는 **정적**으로 만들어야 한다.
- **정적**으로 만든다면 **자동 저장 기간**을 갖고 선언문을 포함하는 블록을 빠져나갈때 파괴된다.
- 수명을 연장하고 싶으면 더 바깥에 있는 범위나 수명이 긴 객체 안에 선언 후 **포인터를 전달**한다.
- 프로그램이 종료될 때까지 살아 있어야 한다면 선언문을 **파일 범위**로 옮긴다.

### 6.3.2 정적 자료구조를 사용하세요
#### std::vector 대신 std:array를 사용하세요
- 배열의 크기가 고정되었거나 사용할 최대 크기를 컴파일 타임에 알 수 있다면 `std::array`를 쓰는게 좋다.
- `std::array`는 비슷한 인터페이스를 제공하지만 고정 크기 배열을 사용하며 메모리 관리자를 호출하지 않는다.

#### 스택에 큰 버퍼를 만드세요
- [문자열을 삽입하면 저장 공간이 커지면서 재할당 하는 비용이 매우 커진다.](/Chapter/Chapter4.md)
- 가장 긴 문자열의 길이를 알고 있다면 자동 저장 공간을 갖는 매우 큰 C스타일 배열을 임시 공간으로 사용한다.

#### 연결 자료구조를 정적으로 만드세요
- 전적으로 초기화된 ㅈ데이터로 연결 자료구조를 구성한다.

#### 이진트리를 배열로 만드세요
- 이진 트리의 각 노드는 왼쪽, 오른쪽 자식 노드를 가리키는 포인터를 포함하는 클래스의 인스턴스이다.
  - 이 방식으로 트리 자료구조를 정의하면 두 포인터를 위한 저장 공간이 더 필요하다.
  - 배보다 배꼽이 더 커지게 된다.
- 자식 노드를 가리키는 포인터를 포함하는 대신 배열을 사용하여 노드의 색인으로 자식 노드의 색인을 계산한다.

#### Deque 대신 원형 버퍼를 사용하세요
- `deque`는 양쪽으로 사용할 수 있는 큐인데 원형 버퍼로도 구현할 수 있다.
- 원형 버퍼는 소비자와 생산자가 엇비슷하다면 재할당할 필요가 없다.

### 6.3.3 new 대신 std::make_shared를 사용하세요
- `std::shared_ptr`과 같은 공유 포인터는 실제로 두 포인터를 포함한다.
    1. 포인터로 참조된 객체
    2. 동일한 객체를 참조하는 모든 `std::shared_ptr`의 참조 수를 저장하는 동적 변수
- `std::shared_ptr<MyClass> p = std::make_shared<MyClass>("Hello", 123);`
  - 참조 수와 MyClass의 인스턴스를 모두 저장하는 단일 메모리 블록을 할당한다.
  - `auto p = std::make_shared<MyClass>("hello", 123);` (C++11 스타일)

### 6.3.4 소유권을 불필요하게 공유하지 마세요
- `std::shared_ptr` 타입의 여러 인스턴스는 동적 변수의 소유권을 공유할 수 있다.
- `std::shared_ptr`에서 참조 수를 증가 및 감소시키면 단순히 증감 명령을 수행하는게 아니라 메모리 진입 장벽 기법을 이용하여 명령 수행 도중 **절대 방해받지 않는 비용이 아주 큰 단위 명령을 수행**한다.
- 어떤 `shared_ptr`의 **수명**이 다른 `shared_ptr`의 수명을 포함한다면 두번째 `shared_ptr`의 비용은 불필요 하므로 둘 중 하나를 일반 포인터로 바꿔주는게 좋다.

### 6.3.5 동적 변수를 소유하기 위한 소유 포인터를 사용하세요
- `std::shared_ptr`은 동적 변수의 관리를 자동화 하지만 비용이 많이 든다.
- 동적 변수를 가리키는 참조나 포인터는 **함수로 전달**하거나, **함수에서 반환**되거나, **변수에 할당**될 수 있지만 소유 참조보다 **수명이 긴 참조는 없다**.
- 소유 참조가 있다면 `std::unique_ptr`을 사용해 효율적으로 구현할 수 있다.

## 6.4 동적 변수의 재할당 줄이기
- 동적 변수를 사용할때는 할당 횟수를 줄일수 있도록 노력해야 한다.

### 6.4.1 동적 변수를 미리 할당해 재할당을 방지하세요
- `std::string`이나 `std::vector`에 데이터를 추가하다 보면 동적 할당 내부 저장 공간이 가득 찬다.
- `reserve()`라는 함수를 통해 인자로 `size_t`타입의 인자 `n`을 넣으면 적어도 `n`개의 항목을 저장할 수 있는 공간을 확보할 수 있다.
- **크기를 계산하거나 추정**할 수 있다면 `reserve()`함수를 호출해 문자열이나 벡터의 내부 저장공간을 확보하는게 좋다.
- 사용자 정의 자료구조를 설계할 때, 배열을 미리 할당해 주는 `reserve()`와 같은 함수를 만들어 편의를 제공해야 한다.

### 6.4.2 반복문 바깥에서 동적 변수를 만드세요
- 반복문 안에 `std::string`같은 타입의 변수 선언을 넣게 되면 **매번 동적 할당**을 하게 된다.
- 변수 선언을 반복문 밖으로 뺀 후 반복문에서는 해당 변수를 `clear()`함수를 호출하여 사용한다.
  - `clear()`함수는 문자열의 길이를 0으로 설정한다.
  - 반복문을 처음 실행한 뒤 다음으로 `std::string`에 저장할 값이 매우 길지 않다면 해당 값은 재할당 되지 않는다.

## 6.5 불필요한 복사 제거하기
```cpp
class BigClass; // 멤버변수가 매우 많은 클래스
BigClass a;
BigClass b;
a = b; // BigClass의 대입연산자 호출. 매우 많은 복사가 일어나고 동적할당이 일어날 수 있다.
```
- 최적화할 곳을 찾으려고 실행이 잦은 코드를 조사하는 개발자는 **대입**과 **선언**에 주의를 기울여야 한다.
- 다음과 같은 위치에 **복사 연산**이 있을 가능성이 존재한다.
  - 초기화 (생성자 호출)
  - 대입 (대입 연산자 호출)
  - 함수 인수 (각 인수 표현식이 형식 인수로 전달되면서 이동 생성이나 복사 생성)
  - 함수 반환 (이동 생성자나 복사 생성자 호출)
  - 표준 라이브러리 컨테이너에 항목을 삽입 (항목은 이동 생성이나 복사 생성됨)
  - 벡터에 항목을 삽입
- [복사 생성에 관한 설명을 다룬 책](https://github.com/tdm1223/EffectiveCpp)

### 6.5.1 클래스 정의에서 원치 않는 복사 방지하기
- 프로그램에 있는 **모든 객체를 복사**할 필요는 없다.
- 클래스 인스턴스를 복사하는 비용이 많거나 복사를 원하지 않는다면 비용이 생기지 않도록 복사를 금지하는 방법이 있다.
  - **복사 생성자**와 **대입 연산자**를 `private`로 선언하면 호출되지 않게 만들 수 있다.
  - `C++11`에서는 **복사 생성자**와 **대입 연산자**의 선언에 `delete` 키워드를 추가하면 동일한 결과를 얻을 수 있다. 
    - 삭제된 생성자를 `public`으로 선언하는게 좋다.

```cpp
// C++11에서 복사를 방지하는 방법
class BigClass{
public:
  BigClass(BigClass const&) = delete;
  BigClass& operator=(BifClass const&) = delete;
}
```

### 6.5.2 함수 호출에서 복사 제거하기
- 함수의 인자가 `int`, `double`과 같은 기본 타입이라면 생성자는 개념적으로 존재할 뿐 실제로 함수가 있지는 않다.
- 함수의 인자가 `std::list`라면 복사 생성자는 새 항목을 만들려고 **메모리 관리자를 호출**하게 된다.
- 인자가 100만개의 항목을 저장하는 `std::list`라면 100만번의 호출이 발생한다.
- 이 비용을 피하기 위해
  - 형식 인수를 아무것도 하지 않는 **복사 생성자**를 갖는 타입으로 정의할 수 있다.
  - 인스턴스를 복사 생성하는 대신 실제 인수를 가리키는 **참조**로 초기화 하는 것이다.

### 6.5.3 함수 반환에서 복사 제거하기
- 함수가 값을 반환하면 반환 타입과 동일한 익명의 임시 변수가 반환값으로 복사 생성 된다.
- `int`, `double`과 같은 기본 타입이 아닌 클래스라면 **복사 생성자**는 일반적으로 **실제 함수를 호출**하게 된다.
- 컴파일러가 복사 생략 또는 반환값 최적화(RVO)를 실행하기도 하지만 `RVO`를 수행할 수 있는 조건은 매우 구체적이다.
- 컴파일러가 `RVO`를 수행하기를 바라는것보다 개발자가 **직접 작업**하는 방법이 더 확실하다.
  - `return` 문을 사용해 값을 반환하는 대신 **출력용 매개변수**를 사용해 값을 반환할 수 있다.
  - **출력용 매개변수**는 함수 안에서 반환된 값으로 갱신하는 **참조 인수**이다.

```cpp
void scalar_product(std::vector<int> const& v, int c, vector<int>& result)
{
  result.clear();
  result.reserve(v.size());
  for (auto val : v)
    result.push_back(val * c);
}
```
- 출력용 매개변수(result)가 함수의 인수 목록에 있을 경우
  - 함수가 호출되었을때 객체는 이미 생성되어 있다.
  - 함수 안에서 갱신된 객체는 `return`문에서 익명의 **임시 객체로 복사**할 필요가 없다.
  - 실제 데이터가 인수로 반환되기 때문에 함수의 반환 타입을 `void`로 하거나 상태 또는 오류 정보를 반환하도록 만들 수도 있다.
  - 갱신된 객체는 호출자의 이름에 바인딩되어 있으므로 함수에서 반환할 때 객체로 복사하거나 할당할 필요가 없다.

### 6.5.4 복사 없는 라이브러리
- 버퍼, 구조체, 다른 자료구조를 함수 인수로 전달할 때 참조를 사용하면 라이브러리의 여러 계층을 오가며 전달하는 과정에서 드는 비용을 줄일 수 있다.
  - 이런 방법으로 구현한 라이브러리를 복사 없는 라이브러리라고 한다.

### 6.5.5 COW 구현하기
- 복사 비용이 큰 동적 변수를 포함하는 클래스 인스턴스를 효율적으로 복사할 때 사용하는 프로그래밍 용어
- `C++` **문자열 클래스**를 구현할 때 많이 사용되었다.
- 원본 객체와 복사한 객체 중 하나가 수정되기 전까지는 두 객체가 같다는 것이다.
- 초기에는 얕은 복사를 하고 객체가 수정될 때까지 **깊은 복사를 지연**시킨다.
- 동적 변수를 참조하는 모든 클래스 멤버는 `std::shared_ptr`와 같이 소유권을 공유하는 스마트 포인터를 사용해 구현된다.

### 6.5.6 슬라이스 자료구조
- **슬라이싱**은 어떤 변수가 다른 변수의 일부를 참조한다는 프로그래밍 용어이다.
- `string_view` 타입은 어떤 문자열의 부분 문자열을 참조한다.
- 슬라이스는 크기가 작고 쉽게 복사할 수 있는 객체이다.
- 슬라이스는 저장 공간을 할당하고, 내용을 부분 배열이나 부분 문자열에 복사하는 데 큰 비용이 들지 않는다.
- 공유 포인터가 슬라이스된 자료구조를 소유한다면, 슬라이스는 절대 안전하다고 할 수 있다.

## 6.6 이동 문법 구현하기
- `C++11`에 추가된 **이동 문법**은 최적화와 관련된 가장 중요한 특징이다.
 
### 6.6.1 표준이 아닌 복사 문법: 고통스러운 핵
- 일반적으로 변수가 **엔티티로 작동할 때 복사본을 만드는 것**은 정의되지 않은 작동으로 가는 지름길이다.
- 엔티티로 작동하는 변수는 **복사 생성자**와 **복사 대입 연산자**를 명시적으로 삭제하는게 좋다.

### 6.6.2 std::swap(): 가난뱅이의 이동 문법
- 두 변수 사이에서 사용할 수 있는 연산으로 **스왑**이 있다. 두 변수의 내용을 서로 교환한다.
- 이동 문법이 추가되기 전에 `std::swap()`의 디폴트 인스턴스화에서는 **새 복사본을 만드고 복사**하였다.(3번의 복사)
- **엔티티**더라도 잘 정의된다.
- **깊은 복사**가 필요한 **동적 변수**가 있는 클래스에서는 **복사 연산**보다 효율적이다.
  - 나머지 클래스에서는 복사 연산보다 효율적이지 않다.
- 스왑은 **소유하는 포인터**와 **단순한 타입**에서는 합리적인 수단이므로 합당한 조치라고 할 수 있다.

### 6.6.3 엔티티의 소유권 공유
- 엔티티는 복사할 수 없지만 엔티티를 가리키는 **공유 포인터**는 복사할 수 있다.
- 공유 포인터를 복사하는 것은 고유한 객체를 가리키는 **참조**를 **추가**로 만드는 것이다.

### 6.6.4 이동 문법의 이동 부분
- 이동은 **소유권 이전**을 처리한다.
- 이동 연산은 복사 연산보다 효율적이며 값과 엔티티 모두 잘 정의되어 있다.
- 객체가 우측값일 때 좌측값이 되도록 객체의 내용을 빼앗길 수 있다.
  - `y=2*x + 1`에서 우측값인 `2*x+1`이 좌측값인 `y`에 뺏길 수 있다.
  - 우측값이 유효한 상태로 남아서 소멸자가 정상적으로 작동하게 만들어야 한다.
- 이동 생성자와 이동 대입 연산자를 개발자가 제공하거나 컴파일러가 자동으로 생성하지 않는다고 하더라도 프로그램은 정상적으포 컴파일된다.
  - 컴파일러는 덜 효율적인 복사 생성자와 복사 대입 연산자를 사용하기 때문에 명시적으로 선언하는것이 좋다.

### 6.6.5 이동 문법을 사용하도록 코드 갱신하기
- 클래스마다 **이동 문법**을 사용하도록 코드를 갱신할 수 있다.
- 코드를 갱신하는 과정에 도움이 되는 체크리스트
  1. 이동 문법을 사용해서 이득을 얻을 수 있는 문제를 파악하자.
     - **복사 생성자**와 **메모리 관리 함수**에 시간을 많이 소비한다면 이동 연산자와 이동 대입 연산자를 추가했을 때 이득을 얻을 수 있다.
  2. `C++` 컴파일러와 표준 라이브러리를 이동 문법을 지원하는 버전으로 갱신하자.
    - 갱신 후에는 성능 테스트를 다시 실행한다.
  3. 서드 파티 라이브러리를 사용한다면 이동 문법을 지원하는 최신 버전이 있는지 확인하자.
    - 라이브러리를 이동 문법을 사용하는 버전으로 갱신하지 않는다면 컴파일러에서 이동 문법을 지원한다고 하더라도 이득이 없다.
  4. 성능 문제가 확인된 클래스에 이동 연산자와 이동 대입 연산자를 정의하자.
    
### 6.6.6 이동 문법의 미묘한 부분
- 이동 문법은 만능이 아닐 수 있다.
- 미묘한 부분이 있으므로 충분한 지식을 갖고 신중하게 사용해야 한다.

#### std::vector 안에 있는 인스턴스 이동하기
- `std::vector`는 벡터를 연산하는 과정에서 예외가 발생하면 연산 전의 벡터로 되돌리는 **강력한 예외 안전성 보장**을 제공한다.
- 복사 생성자는 원본 객체를 변경하지 않고 이동 생성자는 원본 객체를 파괴한다.
  - 이동 생성자에서 발생하는 모든 예외는 강력한 예외 안전성 보장을 위반한다.
- **강력한 예외 안전성 보장**을 제공하는 `noexcept`로 이동 생성자와 이동 대입 연산자를 선언하는것이 좋다.

#### 우측값 참조 인수는 좌측값입니다
- 함수가 우측값 참조를 인수로 가져올 때 우측값 참조를 사용해 형식 인수를 생성한다.
- 형식 인수는 이름이 있으므로 우측값 참조로 생성되었다고 하더라도 좌측값이다.
- `std::move()`를 통해서 좌측값을 우측값 참조로 형변환할 수 있다.

#### 우측값 참조를 반환하지 마세요
- 이동 문법의 또 다른 미묘한 점은 함수의 반환 타입을 우측값 참조로 정의해서는 안 된다는 것이다.
- `RVO`를 적용할 수 있다면 함수 내부의 `return` 구문의 실제 인수와 함수의 반환 타입 반환형 모두 우측값 참조가 되어서는 안된다.

#### 기본 클래스와 멤버 이동하기
- 상속 구조가 존재하는 클래스에 이동 문법을 구현하려면 기본 클래스와 멤버에도 **이동 문법**을 구현해야 한다.
  - 이동 문법을 구현하지 않는다면 기본 클래스와 멤버는 **이동되지 않고 복사**될 것이다.