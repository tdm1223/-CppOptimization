# Chapter6 동적 할당 변수 최적화
- 메모리 관리자의 호출 횟수를 줄이는 방법을 알고 있다면 효과적으로 최적화 할 수 있다.
- 메모리 관리자를 불필요하게 호출해 성능을 저하하는 요인을 제거한다.

## 6.1 C++ 변수
- 모든 C++ 변수는 메모리에 고정된 레이아웃을 가지며 레이아웃의 크기는 **컴파일 타임**에 결정된다.
- C++은 프로그램이 변수의 크기를 바이트 단위로 얻고 그 변수를 가리키는 포인터를 선언하는것을 허용한다.
  - 변수의 레이아웃을 비트 단위로 지정하는 것은 허용하지 않는다.

### 6.1.1 변수의 저장 기간
- 모든 변수는 저장 기간(수명)을 갖는다.
  - 저장 기간이란 변수가 차지하는 저장 공간이나 메모리 바이트가 의미있는 값을 갖는 기간을 말한다.

#### 정적 저장 기간
- **컴파일러**가 예약해둔 메모리에 상주한다.
- **고정 메모리 주소**에서 **고정 크기**를 차지한다.
- 메모리 주소는 **컴파일 타임**에 결정된다.
- 프로그램이 종료될 때까지 예약되어 있다.
- 각 전역 정적 변수는 `main` 함수에 진입하기 전에 생성되며 `main` 함수를 떠난 뒤 파괴된다.
- 정적 변수를 위한 저장 공간을 생성하는 런타임 비용은 없으나 저장 공간을 재사용할 수는 없다.

#### 스레드 지역 저장 기간
- `C++11` 이후 표준으로 작성된 프로그램은 스레드 지역 저장 기간을 갖는 변수를 선언할 수 있다.
- 스레드에 진입할 때 생성되어 스레드가 끝날 때 파괴된다. (수명은 스레드의 수명과 같다고 할 수 있다.)
- 각 스레드는 스레드 지역 변수의 복사본을 갖는다.
- 스레드 지역 변수에 접근하는 비용은 운영체제와 컴파일러에 따라 다르겠지만 정적 변수에 접근하는 비용보다 더 높을 수 있다.
- `C++11` 에서 `thread_local` 키워드로 선언된 변수는 스레드 지역 저장 기간을 갖는다.

#### 자동 저장 기간
- **함수 호출 스택**에서 컴파일러가 예약해둔 메모리에 상주한다.
- **컴파일 타임**에 메모리 크기가 결정되고 자동 변수는 각 함수 호출 **스택 포인터**에서 고정된 오프셋 위치를 가진다.
- 중괄호로 둘러싸인 코드 블록 안에서 존재한다.
- 선언된 곳에서 생성되어 코드 블록을 **빠져나갈 때 파괴**된다.
- 한 번에 사용할 수 있는 **메모리 크기**는 **제한**이 있다.
- 깊이가 매우 깊은 재귀나 중첩된 함수 호출 때문에 제한된 메모리 크기를 초과하면 **스택 오버플로**가 발생한다.
- 함수의 인수 형태로 선언된 변수는 자동 저장 기간을 갖는다.

#### 동적 저장 기간
- 프로그램에서 **요청한 메모리에 상주**한다.
- `C++` 런타임 시스템 함수와 프로그램 대신 메모리 풀을 관리하는 자료구조로 구성된 **메모리 관리자**를 호출한다.
- `new`으로 변수를 동적으로 생성한다.
  - `new` 표현식으로 반환된 변수는 동적 저장 기간을 갖는다.
- `delete`로 변수의 메모리를 메모리 관리자로 반환한다.
- 동적 변수의 주소는 **런타임**에 결정된다.
- 소비하는 저장 공간의 크기가 제한되어 있지 않으며 시간에 따라 변할 수 있다.
- 자동 변수와 달리 동적 변수가 사용하는 메모리를 관리하려면 **런타임 비용**이 많이 필요하다.

### 6.1.2 변수의 소유권
- 변수의 주인은 변수가 생성될 때 와 파괴될 때는 결정한다.

#### 전역 소유권
- 정적 저장 기간을 갖는 변수는 **프로그램**이 전체 소유권을 갖는다.
- `main` 함수에 진입하기 전에 생성되며 `main` 함수를 떠난 뒤 파괴된다.

#### 유효 범위가 지정된 소유권
- 자동 저장 기간을 갖는 변수는 **중괄호로 둘러싸인 코드 블록으로 구성된 유효 범위**가 소유권을 갖는다.
- `main` 함수에서 선언된 자동 변수는 정적 변수와 동일한 수명을 갖는다고 볼 수 있다.

#### 멤버 소유권
- 클래스와 구조체의 멤버 변수는 **클래스 인스턴스**가 소유권을 갖는다.
- 클래스의 인스턴스가 생성될 때 **생성자**로 생성되며 클래스의 인스턴스가 파괴될 때 **소멸자**로 파괴된다.

#### 동적 변수의 소유권
- 동적 변수는 누가 소유권을 갖는지 정의되어 있지 않다.
- `new` 표현식이 포인터를 반환하고 이 포인터를 프로그램에서 명시적으로 관리해야 한다.
- 동적 변수를 가리키는 마지막 포인터가 파괴되기전에 `delete` 표현식으로 동적 변수를 메모리 관리자에 반환해야 한다.

### 6.1.3 값 객체와 엔티티 객체
#### 값 객체
- 프로그램에서 값을 통해 의미를 얻는 변수

#### 값은 서로 교환할 수 있고 비교할 수 있습니다
- 값의 의미는 비트에서 나온 것이지 사용하는 방법에서 나온 것이 아니다.

#### 값은 변경할 수 없습니다
- 값을 4에서 5로 변경해 2 + 2 = 5 로 만드는 연산은 없다.
- 4를 저장하는 정수 타입 변수에 5를 저장하도록 변경할 수는 있다.
  - 유일한 이름을 갖는 엔티티인 변수를 변경하는 것이지 값 4를 변경하는 것이 아니다.

#### 값은 복사할 수 있습니다
- 두개의 문자열 변수에 같은 `HELLO WORLD`라는 값을 지정해도 프로그램은 잘 동작한다.

#### 엔티티
- 프로그램에서 역할에 따라 의미를 얻는 변수

#### 엔티티는 유일합니다
- 프로그램에서 일부 객체는 유일한 정체성을 갖는다.
- 뮤텍스, 심볼 테이블등이 유일한 정체성을 갖는 객체의 예라고 할 수 있다.

#### 엔티티는 변경할 수 있습니다
- 프로그램은 뮤텍스에 락을 걸거나 해제할 수 있다. 그래도 동일한 뮤텍스이다.
- 프록그램은 심볼 테이블에 심볼을 추가할 수 있다. 그래도 심볼 테이블이다.
- 엔티티는 전체로서 의미를 갖는다.
  - 엔티티의 상태를 변경해도 프로그램에서의 근본적인 의미는 변하지 않는다.

#### 엔티티는 복사할 수 없습니다
- 엔티티의 본질은 사용하는 방법에서 나온 것이지 비트에서 나온것이 아니다.
- 시스템 심볼 테이블의 모든 비트를 다른 자료구조로 복사한다고 해서 그 자료구조가 심볼 테이블이 되지는 않는다.

#### 엔티티는 비교할 수 없습니다
- 엔티티가 같은지 비교하는 연산은 의미가 없다.
- 엔티티는 본질적으로 모두 다르다.

## 6.2 C++ 동적 변수 API
### 6.2.1 스마트 포인터는 동적 변수의 소유권을 자동화합니다
- 동적 변수의 소유권은 `컴파일러`가 제어하거나 `C++`이 정의하지 않는다.
- 동적 변수의 소유권은 개발자가 정하며 프로그램 로직으로 인코딩한다.
- 개발자는 모든 실행 경로를 추적해 동적 변수를 메모리 관리자에 제대로 반환하는지 확인해야 한다.
- 한가지 방법으로는 포인터 변수를 클래스의 `private` 멤버로 선언하는 것이다.
    - 클래스의 생성자에서 포인터를 `nullptr`로 설정하거나 동적 변수를 생성하는 `new 표현식`을 포함할 수 있다.
    - 클래스의 소멸자는 동적 변수를 파괴하는 `delete 표현식`을 포함할 수 있다.
    - 포인터에 영향을 주는 곳이 제한되어 코딩, 디버깅이 수월해진다.
- `C++`은 동적 변수의 소유권을 유지하기 위해 `std::unique_ptr`라는 스마트 포인터 템플릿을 제공한다.
    - `unique_ptr`은 효율적인 측면에서 직접 작성한 코드와 필적할 만한 코드로 컴파일 한다.

#### 동적 변수의 소유권 자동화
- **스마트 포인터**는 동적 변수의 **소유권을 자동화**해 동적 변수의 수명과 동적 변수를 소유하는 스마트 포인터의 수명을 연결한다.
- **자동 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 `break` 문이나 `continue`문 등의 선언문을 둘러 싸고 있는 범위를 빠져나갈 떄 소유한 동적 변수를 삭제한다.
- **클래스 멤버**로 선언된 스마트 포인터의 인스턴스는 스마트 포인터를 포함하는 **클래스 인스턴스가 파괴**될 때 소유한 동적 변수를 삭제한다.
- **스레드 지역 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **스레드가 정상적으로 종료**될 때 소유한 동적 변수를 삭제한다.
- **정적 저장 기간**으로 선언된 스마트 포인터의 인스턴스는 **프로그램이 종료**될 떄 소유한 동적 변수를 삭제한다.

#### 동적 변수의 소유권을 공유하면 비용이 더 큽니다
- C++은 **여러 개**의 포인터와 참조가 **하나**의 동적 변수를 가리키는 것을 허용한다.
  - 여러 자료구조가 특정 동적 변수를 가리킨다면 두 개 이상의 포인터가 하나의 동적 변수를 가리킨다.
- 개발자는 어떤 포인터가 동적 변수의 소유자인지 판단해야 한다.
- 소유권을 공유해야 하는 경우 관리할 수 있는 `std::shared_ptr` 을 제공한다.
  - `shared_ptr`의 인스턴스는 동적 변수를 가리키는 포인터와 참조 수를 가지는 동적 객체를 가리키는 또 다른 포인터를 포함한다.
  - `shared_ptr`에 대입하면 참조 수를 1 증가시키고 `shared_ptr`이 파괴되면 소멸자로 참조 수를 1 감소시키고 참조 수가 0이 되면 동적 변수를 삭제한다.

#### std::auto_ptr 대 컨테이너 클래스
- `std::auto_ptr`은 공유되지 않은 동적 변수의 소유권도 관리할 수 있다.
  - `auto_ptr`의 작동 방법은 `unique_ptr`와 비슷하다.
  - `auto_ptr` 은 이동 문법을 구현하지 않으며 복사 생성자가 없다.

### 6.2.2 동적 변수는 런타임 비용이 있습니다
- C++은 기계어로 컴파일된 후 컴퓨터에서 바로 실행되기 때문에 `C++`문장의 비용 대부분은 몇 번의 메모리 접근이 전부이다.
  - 동적 변수의 메모리를 할당하기 위해 수천 번의 메모리 접근이 필요하다.
  - 메모리 관리자를 호출하는 횟수를 한 번만 줄여도 함수의 성능이 크게 향상된다.
- 함수가 메모리 블록을 요청했을 때 이용가능한 메모리 블록이 없다면?
  - 할당 함수는 큰 메모리 블록을 추가로 얻기 위해 가용 메모리 시스템 풀에서 운영체제 커널을 **고비용**으로 호출한다.
  - 메모리가 물리적 `RAM`에 캐시되어 있지 않다면 해당 메모리 영역에 처음 접근할 때는 더 많이 지연될 수 있다.
- 메모리를 할당하는 함수는 요청한 메모리 블록을 할당하려고 **빈 메모리 블록**의 컬렉션을 찾는다.
  - 함수가 빈 메모리 블록을 찾으면 컬렉션에서 블록을 제거한 뒤 반환한다.

## 6.3 동적 변수 사용 줄이기
- 동적 변수를 사용하면 수많은 문제를 해결할 수 있다.
- 모든 문제를 해결하기에는 비용이 너무 크다는 단점이 있다.
- 정적으로 만든 변수는 종종 동적 변수의 작업을 대신 수행할 수 있다.

### 6.3.1 클래스 인스턴스를 정적으로 만드세요
- 컨테이너의 일부가 아닌 대부분의 클래스 인스턴스는 **정적**으로 만들어야 한다.
- **정적**으로 만든다면 **자동 저장 기간**을 갖고 선언문을 포함하는 블록을 빠져나갈때 파괴된다.
- 수명을 연장하고 싶으면 더 바깥에 있는 범위나 수명이 긴 객체 안에 선언 후 **포인터를 전달**한다.
- 프로그램이 종료될 때까지 살아 있어야 한다면 선언문을 **파일 범위**로 옮긴다.

### 6.3.2 정적 자료구조를 사용하세요
#### std::vector 대신 std:array를 사용하세요
- 배열의 크기가 고정되었거나 사용할 최대 크기를 컴파일 타임에 알 수 있다면 `std::array`를 쓰는게 좋다.
- `std::array`는 비슷한 인터페이스를 제공하지만 고정 크기 배열을 사용하며 메모리 관리자를 호출하지 않는다.

#### 스택에 큰 버퍼를 만드세요
- [문자열을 삽입하면 저장 공간이 커지면서 재할당 하는 비용이 매우 커진다.](/Chapter/Chapter4.md)
- 가장 긴 문자열의 길이를 알고 있다면 자동 저장 공간을 갖는 매우 큰 C스타일 배열을 임시 공간으로 사용한다.

#### 연결 자료구조를 정적으로 만드세요
- 전적으로 초기화된 ㅈ데이터로 연결 자료구조를 구성한다.

#### 이진트리를 배열로 만드세요
- 이진 트리의 각 노드는 왼쪽, 오른쪽 자식 노드를 가리키는 포인터를 포함하는 클래스의 인스턴스이다.
  - 이 방식으로 트리 자료구조를 정의하면 두 포인터를 위한 저장 공간이 더 필요하다.
  - 배보다 배꼽이 더 커지게 된다.
- 자식 노드를 가리키는 포인터를 포함하는 대신 배열을 사용하여 노드의 색인으로 자식 노드의 색인을 계산한다.

#### Deque 대신 원형 버퍼를 사용하세요
- `deque`는 양쪽으로 사용할 수 있는 큐인데 원형 버퍼로도 구현할 수 있다.
- 원형 버퍼는 소비자와 생산자가 엇비슷하다면 재할당할 필요가 없다.

### 6.3.3 new 대신 std::make_shared를 사용하세요
- `std::shared_ptr`과 같은 공유 포인터는 실제로 두 포인터를 포함한다.
    1. 포인터로 참조된 객체
    2. 동일한 객체를 참조하는 모든 `std::shared_ptr`의 참조 수를 저장하는 동적 변수
- `std::shared_ptr<MyClass> p = std::make_shared<MyClass>("Hello", 123);`
  - 참조 수와 MyClass의 인스턴스를 모두 저장하는 단일 메모리 블록을 할당한다.
  - `auto p = std::make_shared<MyClass>("hello", 123);` (C++11 스타일)

### 6.3.4 소유권을 불필요하게 공유하지 마세요
- `std::shared_ptr` 타입의 여러 인스턴스는 동적 변수의 소유권을 공유할 수 있다.
- `std::shared_ptr`에서 참조 수를 증가 및 감소시키면 단순히 증감 명령을 수행하는게 아니라 메모리 진입 장벽 기법을 이용하여 명령 수행 도중 **절대 방해받지 않는 비용이 아주 큰 단위 명령을 수행**한다.
- 어떤 `shared_ptr`의 **수명**이 다른 `shared_ptr`의 수명을 포함한다면 두번째 `shared_ptr`의 비용은 불필요 하므로 둘 중 하나를 일반 포인터로 바꿔주는게 좋다.

### 6.3.5 동적 변수를 소유하기 위한 소유 포인터를 사용하세요
- `std::shared_ptr`은 동적 변수의 관리를 자동화 하지만 비용이 많이 든다.
- 동적 변수를 가리키는 참조나 포인터는 **함수로 전달**하거나, **함수에서 반환**되거나, **변수에 할당**될 수 있지만 소유 참조보다 **수명이 긴 참조는 없다**.
- 소유 참조가 있다면 `std::unique_ptr`을 사용해 효율적으로 구현할 수 있다.