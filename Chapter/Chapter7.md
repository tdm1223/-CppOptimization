# Chapter7 문장 최적화
- 문장 수준에서 이뤄지는 최적화는 **프로그램을 실행할 때 불필요한 명령어를 제거**하는 과정
- 반복문
  - 반복문 안에 있는 문장의 비용을 계산할 때는 문장의 비용을 반복 횟수만큼 곱한다.
- 자주 호출되는 함수
  - 함수의 비용을 계산할 때는 함수의 호출 횟수만큼 곱한다.
- 프로그램 전체에서 사용되는 관용구

## 7.1 반복문에서 코드 제거하기
#### 반복문의 두 부분
1. 블록으로 둘러싸여 **반복 실행**되는 문장들
   - `C++` 문장에서 계산을 제거하는 일반적인 기법 적용 가능
2. 반복 횟수를 결정하는 **제어문**
   - 어떤 의미에서는 오버헤드이므로 최적화 할 수 있는 여지 존재

#### 최적화 되지 않은 for문 예제
```cpp
char s[] = "This string has many space (0x20) chars. ";
for(size_t i = 0; i < strlen(s); ++i)
    if(s[i] == ' ')
        s[i] = '*';
```
- `for`문에서 문자마다 조건식 `i < strlen(s)`를 수행한다.
- 알고리즘의 비용은 O(n<sup>2</sup>)이 된다.

### 7.1.1 반복문의 종료값을 캐싱하세요
- 위 예제에서 `strlen()`의 반환값을 초기화 표현식에서 미리 계산해 캐싱하면 성능을 향상할 수 있다.
```cpp
for(size_t i = 0, len = strlen(s); i < len; ++i)
    if(s[i] == ' ')
        s[i] = '*';
```
- 종료값을 캐싱하여 첫번째 코드보다 속도가 약 **20배**정도 빨라진다.

### 7.1.2 더 효율적인 반복문 사용하세요
- C++에서 `for`문의 문법
  - `for (초기화 표현식; 조건식; 증감문) 반복해서 실행할 코드`
- 대략적인 컴파일 결과
```
초기화 표현식;
L1: if (!조건식) goto L2;
      반복해서 실행할 코드;
      증감문;
      goto L1;
L2:
```
- 조건식의 결과가 `false`일 경우 한 번, 증감문을 계산한 후에 한 번 총 두 번 점프해야 한다.
  - 이 점프로 실행 속도가 저하될 수 있다.
- `C++`에서 `do-while` 문
  - `do 반복해서 실행할 코드 while (조건식);`
- 대략적인 컴파일 결과
```
L1: 반복해서 실행할 코드
    if (조건식) goto L1;
```
- `for` 문은 **경우에 따라** 속도가 더 빠른 `do-while`문으로 바꿀 수 있다. (항상 빨라지는것은 아니다)
```cpp
size_t i = 0, len = strlen(s);
do {
    if (s[i] == ' ')
        s[i] = ' ';
    ++i;
} while (i < len);
```
- `for` 문에 비해 **비주얼 스튜디오 2010**에서는 32% 향상되었지만 **비주얼 스튜디오2015**에서는 25% 저하되었다.

### 7.1.3 값을 증가하는 대신 감소하게 하세요
- 종료값을 캐싱하는 예제의 증감문에서 값을 증가하는 대신 **감소**하도록 변형할 수 있다.
- `1에 있는 예제`에서 종료조건인 `strlen()`은 비용이 많이 들기 때문에 증감문을 감소하는쪽으로 변형한다.
```cpp
for (int i = (int)strlen(s)-1; i >= 0; --i)
    if (s[i] == ' ')
        s[i] = '*';
```

### 7.1.4 반복문에서 불변 코드를 제거하세요
```cpp
int i, j, x, a[10];
for (i = 0; i < 10; ++i)
{
    j = 100;
    a[i] = i * j * x * x;
}
```
- `j = 100, j * x * x`는 반복문에 대해 불변한다.
```cpp
int i, j, x, a[10];
j = 100; // 반복문 밖으로 뺀다.
int tmp = j * x * x; // 미리 계산해 둔다.
for (i = 0; i < 10; ++i)
{
    a[i] = i + tmp;
}
```
- 최신 컴파일러는 반복해서 계산하는 불변코드를 찾아 성능을 향상시키고자 코드를 **반복문 바깥**으로 옮긴다.
- 반복문에 대해 불변인 함수 호출은 개발자가 직접 확인해 옮겨야 한다.

### 7.1.5 반복문에서 불필요한 함수 호출을 제거하세요
- `순수함수` : 반환값이 함수의 인수에만 의존하며 사이드 이펙트가 없는 함수
  - 반복문 바깥으로 항상 옮길 수 있는 함수이다.
- 시간 절약이 중요하다면 반복문 안에 있는 모든 함수의 호출을 살펴봐야 한다.

### 7.1.6 반복문에서 숨겨진 함수 호출을 제거하세요
#### 숨겨진 함수 호출의 가능성이 존재하는 상황
1. 생성자 호출
   - 클래스 인스턴스의 선언
   - 클래스 인스턴스의 초기화
2. 대입 연산자 호출
   - 클래스 인스턴스의 대입
3. 연산자 멤버 함수 호출
   - 클래스 인스턴스를 포함하는 산술 표현식
4. 범위에서 선언된 클래스 인스턴스의 소멸자 호출
   - 범위를 빠져나갈때
5. 각 인수 표현식은 형식 인수로 복사 생성
   - 함수 인수
6. 복사 생성자 호출
   - 클래스 인스턴스의 함수 반환
7. 항목이 이동 또는 복사 생성
   - 표준 라이브러리 컨테이너에 항목을 삽입
   - 벡터에 항목을 삽입
```cpp
for (...){
    std::string s("<p>");
    ...
    s += "</p>"; 
} // s의 소멸자 호출
```
- `s`를 선언하는 문장을 `for`문에 넣을 경우 비용이 많이 든다.
- 블록으로 둘러싸인 문장에서 닫는 중괄호에 도달시 `s`의 소멸자가 호출된다.
```cpp
std::string s("<p>");
for (...){
    s.clear();
    s += "<p>";
    ...
    s += "</p>";
}
```
- `s`의 소멸자는 호출되지 않는다.
- 이 작동은 문자열이나 동적 메모리를 포함하는 클래스에 국한되지 않는다.
- 클래스 인스턴스는 윈도우나 파일 핸들과 같이 운영체제에서 가져온 자원을 포함하거나 생성자와 소멸자 내부에서 비용이 큰 코드를 수행할 수도 있다.
    
### 7.1.7 반복문에서 비용이 크고 변화가 느린 호출을 제거하세요
- 반복문을 호출하는 코드 중에는 **불변은 아니지만 불변이라면 더 좋은 경우**가 존재한다.
  - 로그를 기록하는 프로그램에서 현재 시각을 구하기 위해 함수를 호출하는 경우
- 현재 시간은 컴퓨터의 명령어 실행 속도보다 매우 느리게 변한다.
- 시간을 텍스트 형식으로 지정해 문자 배열에 저장하는 커스텀 함수가 있다면
```cpp
char* timetoa(char* buf, size_t bufsz){
    time_t t = std::time(nullptr);
    tm tm = *std::localtime(&t);
    size_t sz = std::strftime(buf, bufsz, "%c", &tm);
    if(sz==0) strcpy(buf, "xx:xx:xx"); // 오류
    return buf;
} // 무려 700나노초나 걸린다.

out << "Fri Jan 01 00:00:00 2021" << "Test log line test log line test log line\n"; // 약 372 나노초가 걸린다.
out << timetoa(buf, sizeof(buf)) << "Test log line test log line test log line\n"; // 약 1042 나노초가 걸린다.
```
- 위 두 코드의 실행 시간은 2배가 넘게 차이가 난다.
- 현재 시간을 가져오는 함수를 **두 번 연속해서 호출**하면 같은 값을 반환할 가능성이 크다.
  - **한번에 여러 줄을 로그로 기록**한다면 줄마다 시간을 다시 가져오는게 좋다.

### 7.1.8 반복문을 함수 안에 넣어 호출 오버헤드를 줄이세요
- 프로그램이 문자열, 배열, 자료구조를 반복하여 매번 함수를 호출한다면 반복문 뒤집기라는 기법을 사용해 성능을 향상할 수 있다.
- 함수의 인터페이스가 단일 항목을 참조하지 않고 자료구조 전체를 함조하게 된다.

- 출력하지 않는 문자를 점 문자로 바꾸는 라이브러리 함수를 예로 들어보자
```cpp
void replace_nonprinting(char& c){
    if(!isprint(c))
        c = '.';
}
```
- 문자열에서 출력하지 않는 문자를 모두 바꾸고 싶다면 반복문으로 `replace_nonprinting` 함수를 호출하면 된다.
```cpp
for (unsigned i = 0; e = str.size(); i < e; ++i){
    replace_nonprinting(str[i]);
}
```

- 컴파일러가 `replace_nonprintin` 함수를 호출하는 코드를 인라인 할 수 없다면 문자열 `Ring the carriage bell\x07\x07!!`을 처리하기 위해 반복문에서 함수를 **26번** 호출할 것이다.

- `replace_nonprinting` 함수에 오버로드를 추가해 문자열 전체를 처리하도록 만들 수 있다.
```cpp
void replace_nonprinting(std::String& str){
    for(unsigned i = 0, e = str.size(); i < e; ++i))
        if(!isprint(str[i]))
            c = '.';
}
```
- 반복문은 함수안에 있다. 따라서 `replace_nonprinting` 함수를 n-1번 호출하는 비용을 절약했다.
```cpp
void replace_nonprinting(std::string& str){
    for (unsigned i = 0, e = str.size(); i < e; ++i)
        replace_nonprinting(str[i]);
}
```

## 7.2 함수에서 코드 제거하기
- 함수는 두 부분으로 구성되어 있다.
  1. **코드 블록** : 함수의 본문
  2. **헤드 부분** : 인수 목록과 반환 타입
- 두 부분을 따로따로 최적화 할 수 있다.
- **함수 본문**을 실행하는 비용은 내용에 따라 커질 수 있지만 **함수를 호출하는 비용**은 매우 작다.
- 함수를 여러번 호출하면 호출 비용이 곱해져 커질 수 있으므로 이를 줄이는것이 중요하다.
- 함수가 있는 프로그램은 길이가 긴 함수가 인라인으로 확장된 똑같은 프로그램보다 작은 용량을 갖는다.
    - 캐시 및 가상 메모리의 성능이 향상된다.
    - 나머지는 모두 똑같기 때문에 자주 호출되는 함수를 더 효율적으로 만들어야 한다.

### 7.2.1 함수 호출 비용
- 함수는 프로그래밍에서 제일 오래되었으며 가장 중요한 **추상화**이다.
- 함수 호출
  1. 함수가 호출되면 컴퓨터는 현재 실행 중인 코드의 **위치를 저장**한다.
  2. 함수 본문으로 **실행 흐름**을 바꾼다.
  3. 함수 호출이 끝나고 이전에 실행하던 명령어의 **다음 위치로 복귀**한다.

#### 함수 호출 시 흐름
1. 실행 코드는 함수의 **인수**와 **지역 변수**를 저장하기 위해 **호출 스택**에 새 프레임을 삽입한다.
2. 각 인수 표현식을 계산한 뒤 스택 프레임에 복사한다.
3. 현재 **실행 주소**를 복사해서 스택 프레임에 반환 주소로 넣는다.
4. 실행 코드는 실행 주소를 함수 본문의 첫 번째 문장으로 갱신한다.
5. 함수 본문에 있는 명령어들을 실행한다.
6. 스택 프레임에 저장되어 있는 반환 주소를 명령어 주소에 복사한다. 함수를 호출한 후의 문장으로 제어권을 넘긴다.
7. 호출 스택에서 스택 프레임을 삭제한다.

#### 함수 호출의 기본 비용
- 함수 호출을 느리게 만들 수 있는 요인
1. 함수 인수
   - 인수 표현식을 계산하는 비용과 각 인수값을 메모리의 스택에 복사하는 비용이 있다.
   - 처음 인수 몇 개는 **레지스터**를 통해 효율적으로 전달한다.
   - 레지스터의 용량이 작기 때문에 인수가 많을 경우 일부 인수를 **스택으로 전달**한다.
2. 멤버 함수 호출
   - 멤버 함수를 호출하는 모든 코드에는 클래스 인스턴스 자신을 가리키는 포인터가 숨겨진 인수로 존재한다.
   - `this` 포인터를 호출 스택에 있는 메모리에 기록하거나 레지스터에 저장해야 한다.
3. 호출과 반환
   - 호출과 반환은 효율적인 프로그램을 만드는 데 아무런 도움이 되지 않는다.
   - 함수를 호출하는 코드가 함수 본문으로 대체되지 않는다면 오버헤드이다.
   - 함수 반환은 스택에서 읽어와 실행 포인터로 불러올 실행 주소가 필요하다.
   - 함수를 호출하고 다시 반환할 때 **비연속적인 메모리 주소**에서 계속 실행한다.

#### 가상 함수의 비용
- `C++`은 모든 멤버 함수를 **가상 함수**로 정의할 수 있다.
- 가상 멤버 함수가 있는 클래스의 각 인스턴스는 `vtable`이라고 하는 테이블을 가리키는 이름 없는 포인터를 포함한다.
- `vtable` 포인터는 역참조 비용을 줄이기 위해 클래스 인스턴스의 **첫 번째 필드**로 만든다.
- 가상 함수를 호출하는 코드는 `vtable`을 가리키는 포인터를 얻기 위해 클래스 인스턴스를 가리키는 포인터를 **역참조** 한다.
- 모든 가상 함수는 호출할 때마다 **비순차적인 메모리**를 추가로 두 번 불러와야 하기 때문에 캐시미스와 실행 파이프라인 스톨의 가능성이 높아진다.

#### 파생 클래스에서의 멤버 함수 호출
- 하나의 클래스가 다른 클래스로부터 파생되었다면 파생 클래스의 멤버 함수는 아래와 같은 작업을 추가로 해야할 수 있다.
1. 파생 클래스에 정의된 가상 멤버 함수
    - 최상위 기본 클래스에 가상 멤버 함수가 없다면 `this` 클래스 인스턴스 포인터에 대한 오프셋을 추가한 뒤 함수 실행 주소를 얻기 위해 `vtable`으로 인덱싱 해야 한다.
2. 다중 상속으로 파생 클래스에 정의된 멤버 함수의 호출
    - 다중 상속된 클래스를 가리키는 **클래스 인스턴스 포인터**를 형성하기 위해 `this`클래스 인스턴스 포인터를 위한 오프셋을 추가해야 한다.
3. 다중 상속으로 파생 클래스에 정의된 가상 멤버 함수의 호출
    - 파생 클래스에서 가상 멤버 함수를 호출할 때 최상위 기본 클래스에 가상 멤버 함수가 없으면, `this` 클래스 인스턴스 포인터에 대한 오프셋을 추가한 뒤 함수 실행 주소를 얻기 위해 `vtable`로 인덱싱해야 한다.
    - 파생 클래스의 클래스 인스턴스 포인터를 형성하기 위해 `this`클래스 인스턴스 포인터에 잠재적으로 다른 오프셋을 추가해야 한다.
4. 가상 다중 상속
    - 가상 다중 상속한 클래스의 인스턴스 포인터를 형성하려면 `this` 클래스 인스턴스 포인터를 위한 오프셋을 추가해야 하는데, 이 오프셋을 결정하기 위해 클래스 인스턴스의 테이블을 역참조 해야 한다.
    - 호출된 함수가 가상 함수일 경우 **오버헤드**가 추가로 발생한다.

#### 함수를 가리키는 포인터의 비용
- 런타임 동안 함수 포인터로 호출된 결과로 실행되는 여러 함수의 본 중 어느 함수를 실행 시킬 것인지 명시적으로 선택할 수 있다.
- 함수를 호출하고 반환하는 기본 비용을 훨씬 능가하는 비용이 추가로 발생한다.
1. 함수 포인터(함수와 정적 멤버 함수를 가리키는 포인터)
    - 프로그래머는 함수 포인터를 사용해 **인수 타입 목록**과 **반환 타입**으로 구성된 특정 시그니처를 갖는 모든 함수를 선택할 수 있다.
    - 런타임에 함수 포인터가 역참조될때 선택한 함수를 호출한다.
    - 프로그램은 함수 포인터에 함수를 대입해 함수 포인터로 어떤 함수를 호출할 것인지 명시적으로 선택한다. 
    - 코드는 함수의 실행 주소를 얻으려면 포인터를 역참조해야 한다. 컴파일러는 이 함수를 인라인할 수 없다.
2. 멤버 함수 포인터
    - 멤버 함수 포인터는 어떤 호출이 발생한 문맥에서 함수 시그니처와 클래스를 모두 식별한다.
    - 프로그램은 함수 포인터에 함수를 대입해 멤버 함수 포인터로 어떤 함수를 호출할지 명시적으로 선택한다.
    - 멤버 함수 포인터는 여러 표현 중 하나를 가질 수 있는데, 복잡한 상황 속에서 모든 멤버 함수를 호출할 수 있어야 한다.
    - 멤버 함수 포인터가 최악의 경우에 해당하는 성능을 갖는다고 가정하는 것도 무리는 아니다.

#### 함수 호출 비용 정리
- 인수가 없는 `void`함수는 호출 비용이 적다.
- 함수를 인라인화하면 비용이 들지 않고, 메모리에 두 번 접근하는 비용과 지역 범위 바깥으로 실행을 두 번 전달하는 비용만 들게 된다.
- 가상 다중 상속 클래스를 포함하지만 가상 함수가 없는 기본 클래스에서 파생된 클래스의 가상 함수를 호출하는 것은 최악의 경우이다.
  - 코드는 클래스 인스턴스 포인터에 더할 오프셋을 결정하기 위해 클래스 인스턴스에 테이블을 **역참조**해야 하기 때문이다.
  - 다중 상속된 함수의 인스턴스 포인터를 형성하고 `vtable`을 얻기 위해 인스턴스를 **역참조**한 뒤 함수의 실행 주소를 얻기 위해 `vtable`을 인덱싱한다.

### 7.2.2 간단한 함수는 인라인으로 선언하세요
- 함수 인라이닝은 코드를 최적화 하는 방법 중 가장 강력한 방법이다.
  - 비주얼 스튜디오에서 **디버그(Debug) 빌드**와 **릴리즈(Release) 빌드**의 성능이 차이나는 이유는 기본적으로 **디버그 빌드**에서 **함수 인라이닝**을 끄기 때문이다.
- 함수 호출 때문에 발생하는 오버헤드를 효과적으로 제거하는 방법은 함수를 인라인하는 것이다.
- 컴파일러가 함수를 인라인하려면 함수를 호출하는 코드를 인라인하는 시점에서 함수 정의에 접근할 수 있어야 한다.
- 클래스 정의 안에 함수 본문이 있는 겨우에는 묵시적으로 인라인 하도록 선언된다.
- 클래스 정의 바깥에 정의된 함수더라도 저장소 클래스를 `inline`으로 선언하면 명시적으로 인라인하도록 선언할 수 있다.

### 7.2.3 함수를 처음 사용하기 전에 정의하세요
- 컴파일러는 함수를 호출하는 코드를 컴파일 할 때 사용 가능한 함수정의가 있다면 인라인할 수 있다.
- 컴파일러가 함수 본문과 호출할 가상 함수를 가리키는 클래스 변수, 포인터, 참조를 인스턴스화하는 코드를 볼 수 있다면 가상 함수 또한 인라인 할 수 있다.

### 7.2.4 사용하지 않는 다형성을 제거하세요
- `C++`에선 **런타임 다형성**을 구현하기 위해 가상 멤버 함수를 사용한다.
- 프로그램이 런타임의 여러 구현 중에 하나를 선택해야 할 경우 가상 함수 테이블은 메모리를 추가로 두 번 불러오고 연관된 파이프라인 스톨의 오버헤드를 발생시킨다.

#### 다형성으로 인한 불필요한 오버헤드
1. 기본 클래스는 원래 구현되지 않은 파생 클래스의 계층 구조를 용이하게 만들기 위한 목적으로 설계되었을 수도 있다.
2. 구현되지 않는 다형성 작동을 예상해 함수를 `virtual`로 선언했을 수도 있다.
- 위 두가지의 경우 기본 클래스의 `virtual` 지정자를 제거하면 함수 호출이 빨라진다.

### 7.2.5 사용하지 않는 인터페이스를 버리세요
#### 링크 타임에 인터페이스 구현 선택하기
- 가상 함수는 실행 중인 프로그램에서 여러 구현 중 하나를 선택할 수 있게 해준다.
- 개발자는 런타임에 결정을 내릴 필요가 없다면 링커를 사용해 여러 구현 중에서 하나를 선택할 수 있다.
- 매우 일반적이라는 장점이 있다.
- 구현을 결정하는 책임이 `.cpp`파일에 일부분 있고 `makefile`이나 `프로젝트 파일`에 일부분 있다는것이 단점이다.

#### 컴파일 타임에 인터페이스 구현 선택하기
- 구현 의존성이 존재한다면 런타임에 결정할 필요가 없다.
- #ifdef를 사용해 컴파일 타임에 구현을 선택할 수 있다.
- 헤더 파일은 유지하고 하나의 cpp 파일에서 전처리기가 구현을 선택하게 된다.
- 더 많은 결정 사항을 볼 수 있다는 장점이 있다.
- 하나의 파일에 여러 구현이 모두 있는것이 지저분하고 객체지향적이지 않다는 단점이 있다.

### 7.2.6 템플릿으로 컴파일 타임에 구현을 선택하세요
- 컴파일 타임에 구현을 선택하는 또 다른 방법으로 `C++ 템플릿 특수화`가 있다.
- 템플릿을 사용해 공통 인터페이스를 갖는 클래스 집합을 만들 수 있다.
    - 템플릿의 타입 매개변수에 따라 작동이 달라진다.
    - 템플릿 매개변수의 타입은 무엇이든 될 수 있다.
        - 자신만의 멤버 함수 집합을 포함하는 클래스 타입
        - 내장 연산자 집합을 포함하는 기본 타입
- 두개의 인터페이스
    - 템플릿 클래스의 `public` 멤버
    - 템플릿 매개변수에서 호출되는 함수 및 연산자로 정의된 인터페이스
- 단점 : 개발자가 특정 템플릿 특수화에서 인터페이스 함수를 구현해야 하는 사실을 잊어버렸을 경우 컴파일러는 오류 메시지를 바로 출력하지 않는다.
- 장점 : 주어진 요구 사항에서 해당 함수를 사용하지 않는다면 필요 없는 함수를 구현하지 않아도 된다.
- 최적화 관점
    - 다형성 템플릿 계층과 템플릿 인스턴스 사이의 가장 큰 차이점은 보통 템플릿은 컴파일 타임에 사용 가능하다는 점이다.
- 템플릿 프로그래밍은 강력한 최적화를 제공한다.

### 7.2.7 PIMPL 관용구를 사용하는 코드를 제거하세요
- `PIMPL`은 컴파일 방화벽으로 사용하는 코딩 관용구로 헤더 파일 하나를 수정했을 때 많은 소스 파일이 재컴파일하지 않게 해주는 메커니즘이다.
- 오래전엔 대규모 프로그램을 컴파일하는데 오래 걸렸기 때문에 사용하였지만, 현재는 컴파일 하는데 걸리는 시간이 90년대에 비하면 1%에 불과하다.
- `PIMPL`이 필요했던 90년대에는 수많은 헤더 파일 때문에 큰 클래스를 사용하였지만 이런 클래스는 객체지향 규칙을 위반한다.

### 7.2.8 DLL을 호출하는 코드를 제거하세요
- 윈도우에서는 함수 포인터를 통해 동적 링크 라이브러리 함수를 호출한다.
- `DLL`이 필요한 시점에 연결되는 방법이면 프로그램은 함수 포인터의 값을 명시적으로 설정한다.
- 프로그램 시작 시에 DLL을 불러오는 방법이면 함수 포인터의 값은 묵시적으로 설정된다.
- `DLL`들을 객체 코드 라이브러리로 변경하고 라이브러리들을 하나의 실행 파일로 만든다면 함수를 호출하는 코드의 성능을 향상시킬 수 있다.

### 7.2.9 멤버 함수 대신 정적 멤버 함수를 사용하세요
- 멤버 함수를 호출하는 모든 코드에는 묵시적 인수가 추가된다.
  - 호출되는 멤버의 클래스 인스턴스를 가리키는 `this` 포인터이다.
  - `this` 포인터의 오프셋으로 클래스 멤버 데이터에 접근한다.
  - 가상 멤버 함수는 vtable 포인터를 얻기 위해 `this` 포인터를 역참조 해야 한다.
- 멤버 함수 중에는 인수에만 의존하며 멤버 데이터에 접근하지 않고 가상 멤버 함수를 호출하지 않는 경우가 있다.
  - `this` 포인터는 아무런 도움이 되지 않는다.
  - 이런 멤버 함수를 `static`으로 선언해야 한다.
  - 정적 멤버 함수는 `this` 포인터가 무엇인지 알 필요가 없다.
  - 정적 멤버 함수를 사용하면 비용이 큰 멤버 함수 포인터 대신 일반 함수 포인터로 참조할 수 있다.
  
### 7.2.10 가상 소멸자를 기본 클래스로 옮기세요
- 파생 클래스가 있는 모든 클래스의 소멸자는 `virtual`로 선언해야 한다.
- `delete` 표현식이 기본 클래스를 가리키는 포인터를 참조한다면 파생 클래스의 소멸자와 기본 클래스의 소멸자가 모두 호출되도록 구현해야 한다.
- 최상단의 기본 클래스에 가상 함수를 선언해야 한다.
  - `vtable` 포인터가 기본 클래스에 포함되게 하기 위해서이다.
- 기본 클래스가 가상 멤버 함수를 선언한다면 `vtable` 포인터는 기본 클래스에서 파생된 모든 클래스 인스턴스에서 오프셋의 위치가 0이다.
  - 기본 클래스에서 적어도 하나의 멤버 함수가 가상 함수라면 `vtable`을 오프셋 0에 위치하도록 강제해 더 효율적인 코드를 생성한다.
- 기본 클래스가 멤버 변수를 선언하고 가상 멤버 변수를 선언하지 않은 상태에서 일부 파생 클래스가 가상 멤버 함수를 선언한다면?
  - 가상 멤버 함수를 호출할때 `vtable` 포인터의 주소를 얻기 위해 `this` 포인터에 오프셋을 모두 추가해야 한다.
- 소멸자는 클래스 인스턴스의 수명 주기 동안 한 번만 호출된다.
  - 프로그램에서 생성 및 파괴 비율이 높은 크기가 매우 작은 클래스를 제외하고는 `virtual`로 만드는 비용이 거의 들지 않는다.

## 7.3 표현식 최적화
- 기본 자료형과 연관된 산술 표현식 수준은 문장 수준보다 아래에 있으며 최적화 할 수 있는 마지막 기회가 있는 곳이다.
- 아주 많이 실행되는 함수가 하나의 표현식으로 구성되었다면 최적화 할 수 있는 유일한 기회가 될 수 있다.

### 7.3.1 표현식을 단순하게 만드세요
- `C++`은 연산자의 우선순위와 결합성에 따라 표현식을 엄격한 순서로 계산한다.
- `a * b + a * c`라는 식을 C++ 컴파일러는 `((a*b)+(a*c))`로 계산한다.
  - 좀 더 효율적인 `a*(b+c)`로 다시 작성하지 않는다.(연산자 우선순위 때문)
- 개발자는 표현식을 가능한 적은 수의 연산자를 사용하는 형태로 작성해야 한다.
- 호너의 규칙을 활용해 표현식을 더 효율적인 형태로 작성할 수 있다.
  - y = ax<sup>3</sup> + bx<sup>2</sup> + cx + d;
    - 곱셈을 6번 하고 덧셈을 3번한다.
  - y = (((a*x + b)*x) + c)*x + d;
    - 곱셈을 3번 하고 덧셈을 3번한다.

### 7.3.2 상수를 함께 모으세요
- 컴파일러는 상수 표현식을 계산할 수 있다.
```cpp
seconds = 24 * 60 * 60 * days;
seconds = days * (24 * 60 * 60);
```
- 위 두 식을 컴파일러는 상수 부분을 계산해 아래와 같이 만든다.
```cpp
seconds = 86400 * days;
```
- 하지만 아채처럼 작성한다면 컴파일러는 곱셈을 런타임에 계산해야 한다.
```cpp
seconds = 24 * days * 60 * 60;
```
- 상수 표현식을 모아 괄호로 묶거나 표현식의 왼쪽에 배치하는것이 좋다.
- `const` 변수의 초기화 값으로 분리하거나 `constexpr` 함수에 넣는 것도 좋은 방법이다.

### 7.3.3 비용이 적은 연산자를 사용하세요
- 어떤 연산자는 다른 연산자보다 계산하는 비용이 적다.
- `x*8`을 `x<<3`으로 작성하면 조금 더 효율적으로 계산할 수 있다.
  - 대부분의 컴파일러가 이 최적화 기법을 지원한다.
- 곱셈 연산을 일련의 시프트 연산과 덧셈 연산으로 다시 작성하는 방법도 있다.
  - `x*9`를 `(x<<3)+x*1`로 다시 작성할 수 있다.
  - 이 최적화는 상수 피연산자가 많은 세트 비트를 포함하지 않을 때 가장 효과적이다.

### 7.3.4 부동 소수점 연산 대신 정수 연산을 사용하세요
- 부동 소수점 연산은 비용이 많이 든다.
- 부동 소수점 숫자는 정규화된 정수인 가수부, 분리된 지수부, 양수와 음수를 구분하기 위한 부호로 구성되어 있다.
- 하드웨어 부동 소수점 연산 장치를 가진 프로세서더라도 정수를 계산하는 속도가 부동 소수점을 계산하는 속도보다 최소 10배 더 빠르다.
#### 부동 소수점으로 정수를 반올림
```cpp
unsigned q = (unsigned)round((double)n / (double)d));
```

#### C++ 런타임 라이브러리 ldiv()를 사용한 정수 나눗셈 반올림
```cpp
inline unsigned div0(unsigned n, unsigned d){
  auto r = ldiv(n, d);
  return (r.rem >= (d >> 1)) ? r.quot + 1 : r.quot;
}
```
- 이 함수는 완벽하지 않다. lvid()의 두 인수가 int 타입의 양수라면 올바른 결과를 생성한다.
- 부동 소수점 버전보다 약 6배 정도 빠르다.

#### 수정한 정수 나눗셈 반올림
```cpp
inline unsigned div1(unsigned n, unsigned d)
{
    unsigned q = n / d;
    unsigned r = n % d;
    return r >= (d >> 1) ? 1 + q : q;
}
```
- 몫과 나머지를 계산하여 나머지가 분모의 절반보다 크거나 같다면 몫을 반올림 한다.
- 부동 소수점 버전보다 약 22배 빠르다!

```cpp
inline unsigned div2(unsigned n, unsigned d)
{
  return (n+(d>>1))/d;
}
```
- 나누기 전에 분모 d의 절반을 분자에 더한다.
- 분자n의 값이 클 경우 `n + (d >>1)` 값이 오버플로할 수 있다는 약점이 있다.
- 부동 소수점 버전보다 약 30배 빠르다!

### 7.3.5 double이 float보다 빠를 수 있습니다
- `C++`은 **x87 FPU 보조 프로세서** 레지스터 스택을 참조하는 부동 소수점 명령어를 생성한다.
  - 이 프로세서에서 부동 소수점은 모두 단일 80비트 형식으로 계산한다.
- 단정도 `float`과 배정밀도 `double`은 `FPU` 레지스터로 옮길 때 길이가 늘어난다.
  - 이때 `float`을 변환하는 시간이 `double`을 변환하는 시간보다 길어질 수 있다.

### 7.3.6 반복 계산을 닫힌 형태로 바꾸세요
#### 정수 값이 2의 거듬제곱인지 확인하는 반복 알고리즘
- 2의 거듭제곱이라면 1인 비트를 하나만 가지므로 2로 나누면서 1인 비트의 수를 세는 방법이다.
```cpp
inline bool is_power_2_iterative(unsigned n)
{
    for (unsigned one_bits = 0; n != 0; n >>= 1)
    {
        if ((n & 1) == 1)
        {
            if (one_bits != 0)
            {
                return false;
            }
            else
            {
                one_bits += 1;
            }
        }
    }
    return true;
}
```

#### 닫힌 형태로 작성한 코드
- x가 2의 n제곱이라면 1인 비트가 n번째 위치에 하나만 있을 것이다.
  - `x-1`은 `n-1, ..., 0`번째 위치에 1인 비트가 있는 비트마스크이므로 `x & (x-1)`은 0이다.
- x가 2의 거듭 제곱이 아니라면 1인 비트가 여러개 있을 것이다.
  - `x-1`은 최하위 1인 비트만 0으로 만드므로 `x & (x-1)`은 0이 아니다.
```cpp
inline bool is_power_2_closed(unsigned n)
{
    return ((n != 0) && !(n & (n - 1)));
}
```
- 반복 알고리즘 보다 2.3배 빠르다.
