# Chapter8 라이브러리 최적화
## 8.1 표준 라이브러리 최적화
### 8.1.1 C++ 표준 라이브러리의 철학
- `C++`은 시스템 프로그래밍 언어로서의 사명을 다하며 다소 엄격하고 간소한 표준 라이브러리를 제공한다.
- 표준 라이브러리는 단순하고 일반화되어 있으며 빠르다.
- `C++` 표준 라이브러리에 포함된 함수와 클래스는 다른 방법으로 제공할 수 없거나 **여러 운영체제**에서 매우 광범위하게 재사용할 수 있기에 채택되었다.
- `C++`의 접근 방법이 갖는 장점 덕분에 운영체제를 지원하지 않는 하드웨어에서도 `C++` 프로그램을 실행할 수 있다.

### 8.1.2 C++ 표준 라이브러리의 사용에 관한 사안
#### 표준 라이브러리 구현에 버그가 있습니다
- 표준 라이브러리는 30년간 계속 발전해 왔다.
  - 단순히 30년된 코드가 아니다.
  - 30년 동안 발전해 왔다.
- 표준 라이브러리는 컴파일러와 별도로 관리한다.
  - 컴파일러도 버그가 존재한다.

#### 표준 라이브러리 구현이 C++ 표준을 준수하지 않을 수 있습니다
- 표준을 준수하는 구현 같은 것은 없다.
- 라이브러리 중 일부는 컴파일러 때문에 사용이 제한된다.
  - 컴파일러가 이동 문법을 지원하기 전에는 라이브러리에서 이동 문법을 사용할 수 없다.

#### 표준 라이브러리의 개발자에게 가장 중요한 것은 성능이 아닙니다
- 성능은 C++ 개발자에게 중요한 요소지만 표준 라이브러리 개발자에게는 가장 중요한 요소가 아닐 수도 있다.
  - 성능이 다른 중요한 요소를 뒷받침하는 요소일 수 있다.
- `C++` 표준의 최신 기능 지원 여부를 확인할 경우네는 적용 범위가 중요하다.
- 라이브러리는 수명이 길기 때문에 **단순성**과 **유지 보수성**이 중요하다.
- 라이브러리를 여러 컴파일러에서 지원할 수 있도록 구현할 경우 **이식성**이 중요하다.

#### 라이브러리의 구현이 최적화 시도를 좌절시킬 수 있습니다.
- 리눅스 `AIO`라이브러리는 파일을 읽기 위한 매우 효율적이고 비동기 인터페이스를 제공한다.
  - 문제는 `AIO`에 특정 커널 버전이 필요하다는 것이다.
  - `AIO`는 리눅스 배포판 대부분이 커널 업데이트를 구현하기 전까지 더 오래되고 속도가 느린 `I/O`로 코딩되었다.
- 개발자는 `AIO`를 호출하는 코드를 작성할 수 있지만 `AIO`의 성능은 얻을 수 없다.

#### C++ 표준 라이브러리의 모든 부분이 똑같이 유용하지는 않습니다
- 정교한 예외 계층 구조, `vector<bool>` 표준 라이브러리 할당자 같은 일부 `C++` 기능은 오랜 테스트를 거치치 않고 표준에 추가되었다.
  - 이런 기능은 코딩을 쉽게 만드는게 아니라 어렵게 만든다.
- 현재 제안된 라이브러리 기능은 부스트 라이브러리에서 검토한 뒤 표준 위원회에서 채택하였다.

#### 표준 라이브러리는 운영체제의 가장 좋은 네이티브 함수만큼 효율적이지 않습니다
- 표준 라이브러리는 비동기 파일 `I/O`처럼 일부 운영체제에서 사용할 수 있는 기능을 제공하지 않는다.
- 최적화 담당 개발자는 표준 라이브러리를 어느 정도까지만 최적화 할 수 있다.
- 성능을 조금이라도 얻고 싶다면 **이식성을 희생**하면서라도 네이티브 함수로 호출해 속도를 끌어올려야 한다.

## 8.2 기존 라이브러리 최적화
- 기존 라이브러리를 최적화하는 작업은 지뢰밭에서 지뢰를 제거하는 작업과 같다.
- 쉽게 최적화할 수 있는 라이브러리들은 이미 최적화되어 있을 가능성이 높다.
- 오픈 소스 라이브러리를 수정하면 프로젝트 버전과 메인 저장소 사이의 호환성이 깨질 가능성이 있다.

### 8.2.1 가능한 한 적게 수정하세요
- 클래스나 함수에 기능을 추가하거나 삭제하지 말자
- 함수 시그니처를 수정하지 말자
- 기능을 추가/삭제하거나 함수 시그니처를 수정하게 되면 수정된 라이브러리와 이 라이브러리를 사용하느 프로그램 간의 호환성이 깨지게 된다.

### 8.2.2 기능을 변경하기 보다는 추가하세요
- 클래스나 함수를 추가하는것은 상대적으로 안전하다.
- 이후 버전에서 추가한 라이브러리와 같은 이름의 클래스나 함수가 정의될 수 있다.
  - 다른 이름을 선택하거나 매크로로 고칠 수 있다.

#### 기존 라이브러리의 성능을 향상할 수 있는 안전한 최적화 방안
- 코드에서 사용하는 관용구를 반영하면서 반복문을 라이브러리 안으로 옮기는 함수를 추가한다.
- 기존 라이브러리에 우측값 참조를 사용하는 함수 오버로드를 추가해 이동 문법을 구현한다.

## 8.3 최적화된 라이브러리 설계
### 8.3.1 서둘러 코딩하면 두고두고 후회합니다
- 인터페이스의 안정성은 라이브러리의 핵심 산출물이다.
- 라이브러리를 설계하는 것은 다른 `C++` 코드를 설계하는 것과 같지만 더 위험할 뿐이다.

### 8.3.2 절약은 라이브러리 설계의 덕목입니다
- 절약은 특정 작업에 초점을 맞추고 해당 작업 수행에 필요한 최소한의 기능만을 포함하는 라이브러리를 의미한다.
  - `KISS` 원칙(keep it simple, stupid) : 간단하고 알기 쉽게 만드는게 좋다는 원리
- 절약하는 라이브러리는 단순하다.
  - `C++` 라이브러리는 크기가 크지만 절약적인 라이브러리이다.

### 8.3.3 라이브러리 바깥에서 메모리 할당을 결정하세요
- [메모리 할당을 결정하는 로직을 라이브러리 함수 바깥으로 내보내는 것](/Chapter/Chapter6.md)이 좋다.
  - 각 호출마다 새로운 저장 공간을 할당하는 대신 가능한 곳의 메모리를 재사용하는 최적화를 구현할 수 있다.
  - 함수에서 다른 함수로 데이터 버퍼를 전달할때 복사하는 횟수가 감소한다.
- 파생 클래스에서 메모리 할당을 결정하게 만들 수 있다.
  - 기본 클래스가 할당된 메모리를 가리키는 포인터만 갖도록 한다.
- 라이브러리 바깥에서 메모리를 할당하는 방법은 함수 시그니처에 영향을 준다.

### 8.3.4 확신이 서지 않으면 속도를 위한 라이브러리 코드를 작성하세요
- 라이브러리 클래스나 함수는 성능이 좋아야 한다.
- 라이브러리 설계자는 성능 문제가 있는 상황에서 언제쯤 라이브러리를 사용할 수 있을지 예측할 수 없다.
- 성능을 향상하는 작업은 어려울 수 있고 불가능할 수도 있다.

### 8.3.5 함수가 프레임워크보다 최적화하기 쉽습니다
- 라이브러리는 **함수 라이브러리**와 **프레임워크** 두 종류가 있다.
  - 프레임워크는 완성된 프로그램 스켈레톤을 구현하는 개념적으로 큰 클래스이다.
  - 라이브러리는 프로그램 구현에 사용되는 구성 요소인 함수와 클래스를 모은 라이브러리이다.
- 두 라이브러리 모두 강력한 기능을 포함하며 사용할 경우 생산성을 향상할 수 있다.
- 개발자 관점에서는 함수 라이브러리가 프레임워크보다 사용하기 쉽다.

#### 함수 라이브러리
- 함수는 테스트할 수 있고 성능을 하나씩 조정할 수 있다는 장점이 있다.
- 함수는 대규모 프로그램에서 어떤 기능을 수행하는 데 초점을 맞추는 방법으로 사용할 수 있다.
  - 대표적으로 그리는 작동을 하는 서브 루틴, URI 파서등이 있다.
  - 라이브러리에서 필요한 만큼의 기능만 링크해 사용한다.
- 잘 설계된 함수는 실행 환경을 가정하지 않는다.

#### 프레임워크
- 프레임워크를 호출하면 모든 시스템이 한꺼번에 작동하기 때문에 변경 사항을 분리하고 테스트하기 어렵다.
- 프레임워크는 관심사의 분리나 단일 책임 원칙을 위반한다.
  - 최적화 하기 어렵다.
- 프레임 워크는 **신의 함수**를 포함한다.
  - 신의 함수는 프레임워크의 여러 부분에서 링크된다.
  - 실제로 사용하지 않는 코드 때문에 실행 파일의 크기가 커진다.
- 프레임워크는 개발자가 원하는 대규모의 일반적인 모델을 기반으로 한다.
  - 모델과 개발자의 요구가 일치하지 않을 경우 비효율적인 결과가 나온다.

### 8.3.6 상속 계층 구조를 평평하게 만드세요
- 추상화에서 클래스의 파생 계층은 대부분 3계층 이하여야 한다.
- 3계층
  - 고통 함수를 갖는 **기본 클래스**
  - 다형성을 구현하는 하나 이상의 **파생 클래스**
  - 복잡한 경우 사용하는 **다중 상속**의 믹스인 계층
- 최적화 관점에서 보면 상속 계층 구조가 깊어질수록 멤버 함수를 호출할 때 계산을 추가로 수행할 확률이 높아진다.
- 부모 계층이 많은 클래스의 생성자와 소멸자가 작업을 수행하려면 긴 체인을 오가야 한다.
  - 긴 체인을 오가는 함수는 자주 호출되지 않지만 성능이 중요한 작업에 비용이 큰 호출이 추가될 수 있는 잠재적 위험을 안고 있다.

### 8.3.7 호출 체인을 평평하게 만드세요
- 파생 클래스와 마찬가지로 추상화 구현에서 함수 호출은 대부분 중첩 횟수가 3회 이하여야 한다.
- 중첩되는 함수 호출
  - 전략을 구현하는 함수나 멤버 함수
  - 클래스의 멤버 함수 호출
  - 추상화를 구현하거나 데이터에 접근하는 `public` 또는 `private` 멤버 함수 호출

### 8.3.8 계층화된 설계를 평평하게 만드세요
- 하나의 추상화를 다른 추상화의 측면에서 구현해 계층화된 설계를 만들 때가 있다.
- 계층 구조일 경우 제일 깊은 계층까지 오가며 성능에 영향을 줄 수 있다.
- 하나의 추상화를 계층화된 방법으로 재구현 할 때도 있다. 재구현 하는 이유는 여러가지이다.
  - 호츌 규약을 변경하는 퍼사드 패턴을 사용해 계층을 구현하기 위해
  - 오류를 반환하는 함수 호출과 예외를 던지는 함수 호출 사이에 전환을 구현하기 위해
  - `PIMPL` 관용구를 구현하기 위해
  - `DLL`이나 플러그인을 호출하기 위해
- 설계자는 상황에 맞춰 판단해야 한다.
- 계층을 전환할 때마다 함수를 추가로 호출해야 하며 모든 호출의 성능을 저하 시킨다.
- 설계자는 계층 전환이 필요한지 2개 이상의 계층을 하나로 압축시킬수 있는지 검토해야 한다.

#### 코드리뷰 가이드라인
- 단일 프로젝트에서 퍼사드 패턴의 인스턴스가 많다면 과도한 설계의 징조일 수 있다.
- 설계가 너무 계층화되었다는 한 가지 징조는 특정 계층이 두 번 이상 타나나는 것이다.
- `PIMPL`의 중첩된 인스턴스는 재컴파일을 하지 않도록 방화벽을 구축한다는 원래 목적을 정당화하기 어렵다.
- 프로젝트별로 `DLL`을 사용해 프로젝트의 버그 수정을 `DLL`에서 다 처리하려고 시도하는 경우도 있다.

### 8.3.9 동적 검색을 피하세요
- 동적 검색은 근본적으로 **비효율적**이다.
- `JSON`이나 `XML` 항목을 찾는 라이브러리는 검색 당 파일 크기에 대해 `O(n)`의 성능을 갖는다.
- 데이블 기반 검색은 `O(logn)`의 성능을 갖는다.
- 구조체에서 데이터 항목을 가져오는 시간은 `O(1)`이며 비례 상수는 작다.

### 8.3.10 '신의 함수'를 조심하세요
- 신의 함수는 프로그램에서 사용할 때 링커가 더 많은 라이브러리 함수를 실행 파일에 추가하도록 하는 고수준 전략을 구현하는 함수이다.
- 실행 파일의 크기가 늘어나면 임베디드 시스템의 물리 메모리를 고갈시켜 버리고 데스크톱 컴퓨터의 가상 메모리 페이징이 증가한다.
- 기존의 라이브러리 중에는 사용하기에 비중이 큰 신의 함수가 있다.
- 좋은 라이브러리는 **신의 함수를 설계 상에서 제거**한다.
- 프레임워크로 설계된 라이브러리에서는 신의 함수가 불가피하다.