# Chapter8 라이브러리 최적화
## 8.1 표준 라이브러리 최적화
### 8.1.1 C++ 표준 라이브러리의 철학
- `C++`은 시스템 프로그래밍 언어로서의 사명을 다하며 다소 엄격하고 간소한 표준 라이브러리를 제공한다.
- 표준 라이브러리는 단순하고 일반화되어 있으며 빠르다.
- `C++` 표준 라이브러리에 포함된 함수와 클래스는 다른 방법으로 제공할 수 없거나 **여러 운영체제**에서 매우 광범위하게 재사용할 수 있기에 채택되었다.
- `C++`의 접근 방법이 갖는 장점 덕분에 운영체제를 지원하지 않는 하드웨어에서도 `C++` 프로그램을 실행할 수 있다.

### 8.1.2 C++ 표준 라이브러리의 사용에 관한 사안
#### 표준 라이브러리 구현에 버그가 있습니다
- 표준 라이브러리는 30년간 계속 발전해 왔다.
  - 단순히 30년된 코드가 아니다.
  - 30년 동안 발전해 왔다.
- 표준 라이브러리는 컴파일러와 별도로 관리한다.
  - 컴파일러도 버그가 존재한다.

#### 표준 라이브러리 구현이 C++ 표준을 준수하지 않을 수 있습니다
- 표준을 준수하는 구현 같은 것은 없다.
- 라이브러리 중 일부는 컴파일러 때문에 사용이 제한된다.
  - 컴파일러가 이동 문법을 지원하기 전에는 라이브러리에서 이동 문법을 사용할 수 없다.

#### 표준 라이브러리의 개발자에게 가장 중요한 것은 성능이 아닙니다
- 성능은 C++ 개발자에게 중요한 요소지만 표준 라이브러리 개발자에게는 가장 중요한 요소가 아닐 수도 있다.
  - 성능이 다른 중요한 요소를 뒷받침하는 요소일 수 있다.
- `C++` 표준의 최신 기능 지원 여부를 확인할 경우네는 적용 범위가 중요하다.
- 라이브러리는 수명이 길기 때문에 **단순성**과 **유지 보수성**이 중요하다.
- 라이브러리를 여러 컴파일러에서 지원할 수 있도록 구현할 경우 **이식성**이 중요하다.

#### 라이브러리의 구현이 최적화 시도를 좌절시킬 수 있습니다.
- 리눅스 `AIO`라이브러리는 파일을 읽기 위한 매우 효율적이고 비동기 인터페이스를 제공한다.
  - 문제는 `AIO`에 특정 커널 버전이 필요하다는 것이다.
  - `AIO`는 리눅스 배포판 대부분이 커널 업데이트를 구현하기 전까지 더 오래되고 속도가 느린 `I/O`로 코딩되었다.
- 개발자는 `AIO`를 호출하는 코드를 작성할 수 있지만 `AIO`의 성능은 얻을 수 없다.

#### C++ 표준 라이브러리의 모든 부분이 똑같이 유용하지는 않습니다
- 정교한 예외 계층 구조, `vector<bool>` 표준 라이브러리 할당자 같은 일부 `C++` 기능은 오랜 테스트를 거치치 않고 표준에 추가되었다.
  - 이런 기능은 코딩을 쉽게 만드는게 아니라 어렵게 만든다.
- 현재 제안된 라이브러리 기능은 부스트 라이브러리에서 검토한 뒤 표준 위원회에서 채택하였다.

#### 표준 라이브러리는 운영체제의 가장 좋은 네이티브 함수만큼 효율적이지 않습니다
- 표준 라이브러리는 비동기 파일 `I/O`처럼 일부 운영체제에서 사용할 수 있는 기능을 제공하지 않는다.
- 최적화 담당 개발자는 표준 라이브러리를 사용해 어느 정도까지만 최적화 할 수 있다.
- 성능을 조금이라도 얻고 싶다면 **이식성을 희생**하면서라도 네이티브 함수로 호출해 속도를 끌어올려야 한다.