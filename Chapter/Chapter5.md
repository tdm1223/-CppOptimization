# Chapter5 알고리즘 최적화
- 몇 초 만에 실행되어야 하는 프로그램이 몇 시간이 걸린다면 선택해야할 최적화는 더 효율적인 알고리즘을 선택하는 것이다.

## 5.1 알고리즘의 시간 비용
- `O(1)` 또는 상수
  - 가장 빠른 알고리즘. 입력값에 상관없는 고정 비율이다.
- `O(logN)`
  - 여러번 호출해도 괜찮다. 대표적인 예로는 이진 검색 알고리즘
- `O(N)` 또는 선형 시간
  - 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다.
- `O(NlogN)`
  - 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 빠른 알고리즘.
  - 입력 값이 크더라도 대처 가능한 수준이다.
- `O(N`<sup>2</sup>`)`, `O(N`<sup>3</sup>`)` ...
  - 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 매우 빠르다.
  - 입력값이 크다면 사용을 고려해야 한다.
- `O(2`<sup>n</sup>`)`
  - 입력값이 커지는 속도보다 시간 비용이 증가하는 속도가 매우 빠르다.
  - 입력값이 작은 경우에만 사용해야 한다.
  - 대표적인 예로는 `TSP` 알고리즘이 있다.

### 5.1.1 최선의 경우, 최악의 경우, 평균의 경우 시간 비용
- 알고리즘은 입력값의 순서에 따라 속도가 정해지므로 성능이 중요한 코드에서 어떤 알고리즘을 사용할지 정할 때는 **최악**을 고려해야 한다.
- 입력값이 정렬되어있다는 사실을 알고 있다면 **최선의 경우**에서 좋은 성능을 보이는 알고리즘을 선택해 프로그램의 실행 시간을 향상시킬 수 있다.

### 5.1.2 상환 시간 비용
- 입력값이 클 때 **전체 시간 비용**을 **입력값**으로 나눈 **평균 시간 비용**

### 5.1.3 기타 비용
- 어떤 알고리즘은 **중간 결과를 저장**해 실행 속도를 높일 수 있다.
  - 중간 저장 비용이 발생할 수 있다.
  - 저장 공간 비용이 큰 알고리즘은 제한된 환경에서 사용하지 못할 수도 있다.
- 어떤 알고리즘은 **병렬화**로 실행 속도를 높일 수 있다.
  - 병렬로 실행 가능한 프로세서가 많아야 한다.

## 5.2 검색과 정렬을 최적화하는 툴킷
1. 평균의 경우에 `big-O` 시간 비용이 많은 알고리즘을 시간 비용이 더 적은 알고리즘으로 바꿀 수 있다.
2. 데이터가 어떤 특징을 가진다면 해당 특징을 활용해 가장 좋은 `big-O` 시간 비용을 갖는 알고리즘을 선택할 수 있다.
3. 알고리즘을 수정해 성능을 향상할 수 있다.

## 5.3 효율적인 검색 알고리즘
### 5.3.1 검색 알고리즘의 시간 비용
1. 선형 검색
  - 시간 비용 : `O(N)`
  - 가장 일반적인 검색 알고리즘
  - 정렬되지 않은 테이블에서 사용할 수 있다.
  - 키 입력 순서에 상관없이 작동한다.
2. 이진 검색
  - 시간 비용 : `O(logN)`
  - 입력 데이터가 `키`를 기준으로 정렬되어 있어야 한다.
  - 키와 테이블의 중간 위치에 있는 요소를 비교해 앞에 있는지 뒤에 있는지 판별한 뒤 테이블을 절반으로 나눈다.
3. 보간 검색
  - 이진 검색과 같이 정렬된 테이블을 두 부분으로 나눈다.
  - 조금 더 효율적으로 분할하기 위해 키의 부가적인 정보를 사용한다.
  - 키가 균일하게 분포되어 있을때 시간 비용 : `O(loglogN)`
  - 테이블이 크거나 테이블 요소를 테스트하는 데 드는 비용이 중요하다면 성능이 매우 향상 될 수 있다.
4. 해싱
  - 키를 해시 테이블의 배열 색인으로 변환한다.
  - 시간 비용 : `O(1)`
  - 최악의 경우 `O(N)`

### 5.3.2 모든 검색 알고리즘은 n이 작으면 같습니다
- 테이블이 **작으면** 모든 알고리즘이 같은 수의 항목을 테스트하게 된다.
- 테이블이 **커지면** 차이가 발생하게 된다.

## 5.4 효율적인 정렬 알고리즘
### 5.4.1 정렬 알고리즘의 시간 비용
- 대부분의 정렬 알고리즘은 평균의 경우 시간 비용이 `O(nlogn)`로 동일한 성능을 보인다.
- 최선의 경우와 최악의 경우 성능과 필요한 공간은 서로 다르다.

| 정렬        | 최선  | 평균          | 최악          | 공간  | 비고                                           |
|-------------|-------|---------------|---------------|-------|------------------------------------------------|
| 삽입 정렬   | n     | n<sup>2</sup> | n<sup>2</sup> | 1     | 최선 : 대부분 정렬된 데이터                    |
| 퀵 정렬     | nlogn | nlogn         | n<sup>2</sup> | nlogn | 최악 : 정렬된데이터 or 피벗이 처음 또는 마지막 |
| 병합 정렬   | nlogn | nlogn         | nlogn         | 1     |                                                |
| 트리 정렬   | nlogn | nlogn         | nlogn         | n     |                                                |
| 힙 정렬     | nlogn | nlogn         | nlogn         | 1     |                                                |
| 팀 정렬     | n     | nlognnlogn    | nlogn         | n     | 최선 : 정렬된 데이터                           |
| 인트로 정렬 | nlogn | nlogn         | nlogn         | 1     |                                                |

### 5.4.2 최악의 경우에 정렬 알고리즘 교체하기
- **퀵정렬**을 가장 많이 사용되는 정렬 알고리즘이다.
  - 내부 **오버헤드**는 매우 작고 평균 성능은 두 키를 비교하는 것을 기반으로 하는 정렬 알고리즘 중에서 가장 빠르다.
  - **퀵정렬**은 이미 정렬된 배열이나 피벗이 처음 또는 마지막일때 결함이 있다.
  - 이런 단점을 극복하고자 피벗을 무작위로 선택하거나 중앙값을 계산한 뒤 초기 피벗으로 사용하고자 많은 사이클을 추가로 소비해야 한다.
- 입력 데이터에 대해 아무것도 알지 못한다면 병합 정렬, 트리 정렬, 힙 정렬 모두 용납할 수 없을 수준의 성능을 보이는 코너 케이스가 없다고 확신할 수 있다.

### 5.4.3 입력 데이터의 특성 활용하기
- 입력 데이터가 정렬되어 있거나 대부분 정렬되어 있다는 사실을 안다면 **삽입 정렬**이 뛰어난 성능을 보인다. `O(n)`
- **팀 정렬**은 새로운 하이브리드 정렬 알고리즘으로 정렬되어 있을때 `O(n)`, 나머지의 경우 `O(nlogn)`의 성능을 보이고 파이썬에서 표준으로 사용한다.
- **인트로 정렬**은 퀵 정렬과 힙 정렬의 하이브리드 정렬 알고리즘이다. 최악의 경우 `O(nlogn)`을 보장한다. c++11이후 `std::sort()`구현시 선호하는 알고리즘이다.
- **플래시 정렬**은 특정 확률 분포에서 추출된 데이터에 대해 `O(n)`의 성능을 보인다. (기수정렬과 연관되어 있다)

## 5.5 최적화 패턴
- 최적화된 코드에는 반복되는 패턴이 있다.

### 5.5.1 사전 계산
- 프로그램 실행 초기, **링크** 타임, **컴파일** 타임, **디자인** 타임에서 자주 사용하는 코드를 미리 계산하는 최적화 기법
- 일찍 계산할 수록 좋다.
- 계산할 값이 문맥에 종속되지 않는 선에서 가능하다.

### 5.5.2 지연 계산
- 계산 코드를 **실제로 필요한 부분**과 최대한 **가까운 곳**으로 미뤄서 계산하는 최적화 기법
- 인스턴스를 정적으로 생성하려고 할때 생성자는 객체의 모든 정보를 한꺼번에 할당하지 않고 빈 객체를 생성하는 데 필요한 최소한의 코드만 포함한다. 
  - 프로그램 실행 과정에서 초기화 멤버 함수를 호출해 정보를 할당한다.
- 객체를 하나의 인스턴스에서 다른 인스턴스로 복사할 때, 동적 멤버 변수를 복사하는 대신 하나의 복사본을 공유한다.
  - 변수를 수정할때 까지 복사를 지연한다.

### 5.5.3 배칭
- 한번에 여러 항목을 계산하는 최적화 기법
- **반복된 함수 호출 코드**와 **한 번에 하나씩 처리**할 때 발생하는 계산 코드를 제거할 수 있다.
- 버퍼가 꽉 차거나 프로그램이 라인 끝이나 파일 끝에 도달할 때까지, 출력 문자를 버퍼에 추가한다.
  - 각 문자마다 출력 함수를 호출하지 않고 버퍼 전체를 한 번만 전달한다.

### 5.5.4 캐싱
- 계산 비용이 높은 코드의 결과를 저장한 뒤 재사용해 계산량을 줄이는 최적화 기법
- 스레드 풀
  - 생성하는 비용이 큰 스레드를 캐싱하는 방법이다.
- 캐시 메모리
  - 프로세서에서 자주 사용하는 메모리 위치에 더 빠르게 접근할 수 있도록 해주는 특수 장치이다.
- `C 스타일의 문자열`에서 길이를 알려면 매번 문자수를 세어야 하나 `std::string`은 **문자열의 길이**를 캐싱한다.

### 5.5.5 특수화
- 일반화의 반대말로 어떤 특정 상황에서 필요하지 않은 고비용 계산을 제거하는 최적화 기법
- 고정 길이를 갖는 문자열만 비교한다면 `std::string`대신 C스타일의 배열, 포인터, 비교 함수가 더 나은 성능을 보인다.

### 5.5.6 더 큰 조각 선택하기
- 입력 데이터를 한번에 많이 가져와 반복 작업을 줄이는 최적화 기법
- 반복 과정에서 생기는 오버헤드를 줄이고 반복 횟수를 줄인다.

### 5.5.7 힌팅
- 힌트를 사용해 연산 비용과 계산량을 줄이는 최적화 기법
- `std::map`의 멤버 함수인 `insert()`의 오버로드 중 하나는 **삽입 위치**를 인수로 받는다.
- 이 인수에 위치를 전달할 것인지 선택할 수 있는데 위치를 전달하면 삽입 비용이 `O(1)`이 되고 그렇지 않으면 `O(logn)`이 된다.

### 5.5.8 예상 경로 최적화
- 발생할 가능성이 가장 낮은 입력이나 이벤트의 런타임부터 테스트하는 최적화 기법
- `else-if`문이 여러개 있는 `it-then-else` 코드에서 무작위로 조건문을 배치하는 것보다 만족할 확률이 높은 조건문을 **가장 앞**으로 배치한다.
    
### 5.5.9 해싱
- **크기가 큰 자료구조**(ex.가변 길이를 갖는 문자열)를 해시라 하는 정수로 변환하는 최적화 기법
- 두 입력값을 해시로 변환하면 **입력값이 동일한 경우**를 배제해 효율적으로 비교할 수 있다.
- 해시가 다르면 입력값은 절대로 같지 않다.
- 해시가 같으면 입력값이 같을수도 다를수도 있다.

### 5.5.10 이중 검사
- **비용이 크지 않은 검사**를 수행하되, **비용이 큰 검사**는 필요한 경우에만 수행
- 두 `std::string`이 같은지 확인하려면 **문자단위로 비교**(비용이 큰 검사)해야 하지만 **문자열의 길이를 미리 비교**(비용이 크지 않은 검사)해 다르다면 비교하지 않아도 된다.