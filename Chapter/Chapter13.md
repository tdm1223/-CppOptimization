# Chapter13 메모리 관리 최적화
- 메모리 관리자는 동적 변수의 메모리 할당을 감독하는 `C++` 런타임 시스템의 함수 및 자료구조 집합이다.

## 13.1 C++ 메모리 관리 API
### 13.1.1 동적 변수의 생명 주기
- 동적 변수의 생명 주기는 5(할당, 배치, 사용, 파괴, 해제)단계로 나눌 수 있다.
- `new` 표현식은 **할당 단계**와 **배치 단계**를 수행한다.
- `delete` 표현식은 **파괴 단계**와 **해제 단계**를 수행한다.

#### 할당
- 프로그램은 메모리 관리자에게 연속적인 메모리 영역을 가리키는 포인터를 반환하도록 요청한다.
- 포인터는 적어도 지정된 수만큼의 타입이 없는 메모리 바이트를 포함하고 있어야 한다.
- 메모리를 사용할 수 없는 경우 할당을 실패할 수 있다.
- `malloc()`, `operator new()`의 다양한 오버로드가 할당 단계를 관리한다.

#### 배치
- 프로그램은 할당된 메모리에 값을 저장해 **동적 변수의 초기값**을 설정한다.
- 변수가 **클래스 인스턴스**라면 클래스의 **생성자**중 하나가 호출된다.
- 변수가 **타입**이라면 **선택적**으로 초기화 된다.
- 생성자가 예외를 던질 경우 메모리 관리자에게 할당된 저장 공간을 반환해야 하므로 배치를 실패할 수 있다.
- `new` 표현식이 배치 단계에 포함된다.

#### 사용
- 프로그램은 동적 변수의 값을 읽고 멤버 함수를 호출하며 값을 쓴다.

#### 파괴
- 동적 변수가 갖는 시스템 자원을 반환하고 정리를 완료한다.
- 변수가 클래스 인스턴스라면 프로그램은 클래스의 소멸자를 호출해 동적 변수에 대한 최종 작동을 수행한다.
- 소멸자가 처리되지 않은 예외를 던질 경우 파괴를 실패할 수 있다.
- 소멸자를 명시적으로 호출하면 저장 공간을 해제하지 않고 변수를 파괴할 수 있다.
- `delete` 표현식이 피괴 단계를 관리한다.

#### 해제
- 프로그램은 이전에 파괴된 동적 변수에 속하는 저장 공간을 메모리 관리자에게 반환한다.
-` free()`, `operator delete()`의 다양한 오버로드가 해제 단계를 수행한다.

### 13.1.2 메모리를 할당하고 해제하는 메모리 관리 함수
- `C++`은 `C`의 `malloc()`과 `free()`를 대신하는 메모리 관리 함수를 제공한다.
- 이 함수는 `new` 표현식의 작동을 다채롭게 제공한다.

#### operator new()는 할당을 구현합니다
- `new` 표현식은 `operator new()` 또는 `operator new[]()`의 여러 버전 중 하나를 호출해 동적 변수를 위한 메모리를 얻는다.
- `C++`은 두 종류의 연산자를 위한 **기본 구현을 제공**한다.
- 묵시적으로 선언하므로 `<new>`헤더를 포함하지 않고도 프로그램에서 호출할 수 있다.
- 프로그램에서 기본 구현을 재정의 할 수도 있다.
- `C++`은 `operator new()`의 여러 오버로드를 정의한다.

#### void* ::operator new(size_t)
- 동적으로 할당된 변수에 메모리를 할당한다.
- 할당할 최소 바이트 수를 지정하는 인수를 받는다.
- 메모리가 부족할 경우 `std::bad_alloc` 예외를 던진다.
- `operator new()` 오버로드의 표준 라이브러리 구현은 모두 이 오버로드를 호출한다.
- 표준 라이브러리는 보통 `malloc()`을 호출하는 방법으로 구현한다.

#### void* ::operator new[](size_t)
- 이 오버로드를 호출해 배열을 할당한다.
- 표준 라이브러리 구현은 `::operator new(size_t)`를 호출한다.

#### void* ::operator new(size_t, const std::nothrow_tag&)
- `operator new()`의 **예외를 던지지 않는 오버로드**를 호출한다.
- 메모리가 부족할 경우 `std::bac_alloc` 예외 대신 `nullptr`를 반환한다.
- 표준 라이브러리 구현은 `operator new(size_t)`를 호출하고 던지는 예외를 모두 잡는다.

#### void* ::operator new[](size_t, const std::nothrow_tag&)
- 예외를 던지지 않는 `operator new()` 오버로드의 **배열 버전**이다.
- `new` 표현식을 첫 번째 인수가 `size_t` 타입인 임의의 시그니처와 함께 `operator new()`를 호출할 수 있다.
- 메모리 지정 `operator new()`라고 부른다.
- `new` 표현식은 메모리 지정 매개변수의 인수 타입과 사용 가능한 `operator new()` 함수 시그니처를 똑같이 만들어 어떤 함수를 사용할지 결정한다.

#### void* ::operator new(size_t, void*)
- 변수를 위한 메모리 지정 `operator new()`이다.
- 메모리를 가리키는 포인터를 두 번째 인수로 받고 해당 포인터를 반환한다.

#### void* ::operator new[](size_t, void*)
- 메모리 지정 `operator new()`의 **배열 버전**이다.
- 메모리를 가리키는 포인터를 두 번째 인수로 받고 해당 포인터를 반환한다.
- 메모리 지정 `operator new()`의 두 오버로드를 메모리 `지정 new 표현식 new(p) type`이라고 한다.
- `p`는 유효한 저장 공간을 가리키는 포인터이다.
- `C++` 코드는 개발자 코드로 두 오버로드를 개체할 수 없다고 규정한다.
- 오버로드를 대체했는데 포인터 인수를 반환하는 작동이 아니면 표준 라이브러리 상당 부분이 정상적으로 작동하지 않을 것이다.

#### operator delete()는 할당된 메모리를 해제합니다
- `delete` 표현식은 `operator delete()` 또는 `operator delete[]()` 를 호출해 동적 변수에 할당된 메모리를 런타임 시스템에 반환한다.
- `new` 연산자와 `delete` 연산자는 메모리 할당과 해제를 위해 함께 사용된다.
- 특별한 메모리 풀에서 메모리를 할당하거나 특별한 방법으로 메모리를 할당하는 `operator new()`를 정의한다면 동일한 범위에서 `operator new()`와 일치하는 `operator delete()`를 정의해 메모리를 할당한 풀로 반환해야 한다.
  - 그렇지 않으면 정의되지 않은 작동을 한다.

#### C 라이브러리의 메모리 관리 함수
- `C++`은 메모리를 할당하는 `C`라이브러리 함수 `malloc()`, `alloc()`, `realloc()`과 반환하는 함수 `free()`를 제공한다.
- `C`프로그램과의 **호환성**을 위해 제공된다.
- `void* malloc(size_t size)`는 동적 변수의 생명 주기 중 **할당 단계**를 구현한다.
  - `size` 바이트를 저장하기에 충분한 저장 공간을 가리키는 포인터를 반환한다.
  - 저장 공간이 부족하다면 `nullptr`를 반환한다.
- `void free(void* p)`는 동적 변수의 생명 주기 중 **해제 단계**를 구현한다.
  - `p`가 가리키는 저장 공간을 메모리 관리자에게 반환한다.
- `void* calloc(size_t count, size_t size)`는 동적 변수의 생명 주기 중 **할당 단계**를 구현한다.
  - 배열의 요소 개수인 `count`와 각 요소의 바이트 크기인 `size`를 곱해 전체 요소의 바이트 크기로 변환한뒤 `malloc()`을 호출한다.
- `void* realloc(void* p, size_t size)`는 메모리 블록의 크기를 바꾸고 필요에 다라 블록을 새 저장 공간으로 옮긴다.
  - 기본 블록의 내용은 새 블록 크기와 기존 블록 크기의 최소값까지 새 블록에 복사된다.
  - 매우 조심해서 사용해야 한다.
  - 포인터가 가리키는 블록을 옮기고 기존 블록을 삭제할수 있는데 이러면 기존 블록을 가리키는 포인터가 무효화된다.

### 13.1.3 new 표현식은 동적 변수를 생성합니다
#### new 표현식
- C++ 프로그램은 `new` 표현식을 사용해 동적 변수나 동적 배열의 생성을 요청한다.
- 키워드 `new`, 뒤이어 나오는 타입, 반환된 값을 가리키는 포인터를 포함한다.
- 변수나 배열 요소의 초기값을 설정할 수 있는 **이니셜라이저**를 포함할 수 있다.
- 완전히 초기화된 `C++` 변수나 배열을 가리키는 타입이 있는 포인터를 반환한다.
- 동적 변수나 동적 배열의 첫 번째 요소를 가리키는 **우측값 포인터**를 반환한다.
- `operator new()` 함수를 호출해 저장 공간을 할당하는 것 이상의 기능을 수행한다.
  - `operator new()`를 성공적으로 호출했다면 배열이 아닌 버전은 `type` 객체를 생성한다.
  - 생성자가 예외를 던진다면 멤버와 베이스는 파괴되고 `operator delete()`를 호출해 할당된 메모리를 반환한다.
- `operator delete()`의 시그니처는 메모리 할당에 사용한 `operator new()`함수와 일치한다.
  - `operator delete()`가 없다면 메모리를 반환하지 않으므로 누수의 위험이 있다.
- 포인터를 반환하거나 잡은 에외를 다시 던지거나 예외를 던지지 않을 경우 `nullptr`를 반환한다.

#### 던지지 않는 new
- `placement-params`가 `std::nothrow` 태그로 구성되었다면 `std::bad_alloc`을 던지지 않는다.
- 객체를 생성하지 않고 `nullptr`를 반환한다.

#### 메모리 지정 new는 할당 없이 메모리를 지정합니다
- `placement-params`가 기존의 유효한 저장 공간을 가리키는 포인터라면 `new` 표현식은 메모리 관리자를 호출하지 않고 포인터가 가리키는 위치에 `type`만 지정한다.
- 포인터는 `type`을 저장할 만큼 충분한 저장공간을 가리켜야 한다.
```cpp
char mem[1000];
class Foo{...};
Foo* foo_p = new (mem) Foo(123);
```
- 클래스 `Foo`의 인스턴스를 배열 `mem`위에 배치한다.
- 메모리 지정 `new`는 클래스의 생성자를 호출해 클래스 인스턴스의 초기화를 수행한다.
- 기본 타입의 경우 생성자를 호출하는 대신 초기화를 수행한다.
- 저장 공간을 할당하지 않으므로 상응하는 메모리 지정 `delete`는 존재하지 않는다.

#### 사용자 정의 메모리 지정 new: 형태를 반쯤 갖춘 할당
- `placement-params`가 `std::nothrow`나 단일 포인터가 아닌 다른 것이라면 **사용자 정의 메모리 지정 new**를 호출한다.
- C++은 사용자 정의 **메모리 지정 new 표현식**에 의미를 부여하지 않는다.
  - 개발자는 이를 지정되지 않은 방법으로 저장 공간을 할당하는 데 사용할 수 있다.
- 사용자 정의 **메모리 지정 new 표현식**은 첫 번째 인수가 `size_t`와 일치하고 이후 인수들이 표현식 목록의 타입들과 일치하는 `operator new()` 또는 `operator new[]()`의 오버로드를 검색한다.
- 동적 객체의 생성자가 **예외**를 던지면 메모리 지정 `new` 표현식은 첫 번째 매개변수가 `void*` 이고 이후 인수들이 표현식 목록의 타입들과 일치하는 `operator delete()` 또는 `operator delete[]()`의 오버로드를 검색한다.
- 사용자 정의 메모리 지정 `new`의 문제는 일치하는 사용자 정의 메모리 지정 `delete`를 지정할 수 있는 방법이 없다는 것이다.
  - 객체의 생성자가 `new`표현식에서 예외를 던질때 `operator delete()`의 다양한 메모리 지정 오버로드가 호출된다.
  - `delete`표현식은 이 오버로드들을 호출할 수 없다.

#### 클래스 한정 operator new()는 할당을 세부적으로 제어할 수 있습니다
- `new` 표현식은 타입이 만들어지는 범위내에서 `operator new()`를 검색한다.
- 클래스 한정 `operator new()`를 구현하면 클래스의 할당을 세부적으로 제어할 수 있다.
  - 정의하지 않으면 **전역 범위의 연산자**를 사용한다.
  - 전역 범위 `operator new()`를 사용하고 싶으면 전역 범위 연산자 `::`를 지정하면 된다.
- 클래스 한정 `operator new()`는 해당 함수를 정의하는 클래스의 **인스턴스를 할당하는 경우**에만 호출된다.
  - 다른 클래스와 관련된 `new`표현식을 포함하는 클래스의 멤버 함수는 다른 클래스에서 정의된 operator new()가 있다면 사용하고 아니라면 전역 범위의 `operator new()`를 사용한다.
- 클래스 한정 `operator new()`는 단일 크기의 객체를 할당하므로 효율적일 수 있다.
  - 첫 번째 자유 블록을 항상 사용할 수 있다.
  - 클래스가 여러 스레드에서 사용하지 않는다면 내부 자료구조를 스레드 세이프하게 만드는 오버헤드를 생략할 수 있다.
- 클래스 한정 `operator new()`는 정적 멤버 함수로 정의된다.
- 클래스가 사용자 정의 `operator new()`를 구현할 경우 해당 `operator delete()`를 구현해야 한다.
  - 구현하지 않으면 전역 `operator delete()`를 호출해 정의되지 않은 작동을 하여 원하지 않은 결과가 나오게 된다.

### 13.1.4 delete 표현식은 동적 변수를 없앱니다
- 프로그램은 `delete` 표현식을 사용해 동적 변수가 사용하는 메모리를 메모리 관리자에게 반환한다.
- `delete` 표현식은 동적 변수의 생명 주기에서 변수를 **파괴**하고 이전에 사용하던 메모리를 **해제**하는 마지막 두 단계를 처리한다.
- `delete` 표현식은 키워드 `delete`와 삭제할 변수를 가리키는 포인터를 생성하는 표현식을 포함한다.
- 동적 변수에 잘못된 `delete` 표현식을 사용하면 `C++`표준에서 정의되지 않은 작동을 한다.

### 13.1.5 소멸자를 명시적으로 호출하면 동적 변수를 파괴합니다
- `delete` 표현식을 사용하는 대신 **소멸자를 명시적으로 호출**하면 저장 공간을 해제하지 않고 동적 변수의 파괴 작동만 수행할 수 있다.
```cpp
foo_p->~Foo();
```
- 소멸자를 명시적으로 호출하는 위치는 메모리 지정 `new`를 호출하는 위치와 같다.
- 표준 라이브러리의 템플릿 `Allocator`는 파괴와 해제가 별개로 일어난다.

#### 생성자를 명시적으로 호출할 방법이 있을까
- 프로그램은 생성자를 직접 호출할 수 없다.
- 생성자는 `new` 표현식을 사용해 호출된다.
- 프로그램이 **이미 생성된 클래스 인스턴스에서 생성자를 명시적으로 호출하는것**은 간단하다.
```cpp
class Blah{
public:
    Blah() {...}
};

Blah * b = new char[sizeof(Blah)];
Blah myBlah;

new (b) Blah;
new (&myBlah) Blah;

b->Blah::Blah();
```

## 13.2 고성능 메모리 관리자
- 저장 공간의 모든 요청은 `::operator new()`를 거쳐가고 해제된 저장 공간은 `::operator delete()`를 거쳐간다.
  - 이런 함수들은` C++`의 **기본 메모리 관리자**를 형성한다.
- 대부분의 `C++` 컴파일러에서 제공하는 `::operator new()`는 C함수` malloc()`을 래핑한 함수이다.

#### C++의 기본 메모리 관리자가 충족해야 할 요구 사항
- 자주 실행될 가능성이 있으므로 **효율적인 성능**을 발휘해야 한다.
- **멀티스레드 프로그램**에서 올바르게 작동해야 한다.
  - 기본 메모리 관리자에서 자료구조에 접근하는 작동이 **직렬화**되어 있어야 한다.
- 크기가 같으면서 개수가 많은 객체(노드 등)들을 효율적으로 할당해야 한다.
- 크기가 다르면서 개수가 많은 객체(문자열 등)들을 효율적으로 할당해야 한다.
- 매우 큰 자료구조(I/O 버퍼)와 작은 자료구조(단일 포인터)를 할당해야 한다.
- 효율성을 극대화 하려면 포인터, 캐시 라인, 가상 메모리 페이지, 최소한 더 크게 할당된 메모리 블록에 대한 **맞춤 경계**를 알고 있어야 한다.
- 시간이 지나면서 런타임 성능이 저하되어선 안된다.
- 반환된 메모리를 효율적으로 재사용해야 한다.

#### malloc()을 대체할 수 있는 고성능 라이브러리
- `Hoard`
  - 멀티 프로세서 메모리 할당자의 상용화 버전이다.
  - `malloc()`보다 성능이 3~7배 향상되었다고 주장한다.
- `mtmalloc`
  - 솔라리스에서 고도의 멀팊스레드 방법인 워크로드를 대체하기 위한 `malloc`이다.
  - **최적 적합 할당자**를 사용한다.
- `ptmalloc`(glibc malloc)
  - 리눅스 3.7 버전 이후에서 함께 제공되는 `malloc`이다.
  - 멀티스레드 프로그램에서 경합을 줄이기 위해 스레드마다 아레나가 있다.
- `TCMalloc`(Thread-Caching malloc())
  - 구글에서 만든 `malloc()` 대체 라이브러리이다.
  - 크기가 작은 객체를 위해 특수화된 할당자와 대규모 블록을 관리하기 위해 설계된 스핀락이 있다.
  - 리눅스에서만 사용할 수 있다.

#### 최신 메모리 관리자를 잘 사용하지 않는 이유
- 성능을 비교할 때 기준이 되는 메모리 관리자가 무엇인지 명확하게 나타내지 않으면 비현실적인 허수아비가 될 수 있다.
  - 윈도우 7, 리눅스 3.7 이후 메모리 관리자를 바꾸더라도 성능이 향상되지 않을 수 있다.
- **동적 변수의 할당 및 해제가 프로그램 실행 시간을 좌우할 경우**에만 성능 향상에 도움이 된다.
- 메모리 관리자를 호출하는 횟수를 줄이면 할당자의 속도와 관계없이 성능을 향상할 수 있다.
- 최신 메모리 관리자는 성능을 향상하기 위해 캐시 및 자유 블록 풀에 메모리를 소비한다.
  - 제약 조건이 있는 환경에서는 메모리를 추가로 사용할 수 없을 수도 있다.
