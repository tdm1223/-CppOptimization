## 컴퓨터 하드웨어와 최적화
- 컴퓨터는 메모리에 저장된 명령을 실행하는 방법으로 작동한다.

### C++은 컴퓨터의 거짓말을 믿는다.

### 컴퓨터의 진실
1. 메모리는 **느리다**.
    - 메인 메모리는 마이크로프로세서에 있는 **게이트**와 **레지스터**보다 매우 느리다.
    - **메모리에 접근하는 비용**은 **프로세서의 다른 비용들을 압도**한다.
    - [폰 노이만 병목현상](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0)
2. 메모리는 **워드 단위**로 접근한다.
    - `int`, `double`, `포인터`처럼 여러 바이트를 갖는 자료형을 가져올때 해당 데이터를 구성하는 바이트가 실제 메모리에서는 **두개의 워드**에 걸쳐 있을 수 있다. (unaligned memory access)
    - 두 워드를 읽어야 하기 때문에 모든 바이트가 같은 워드에 있을 때보다 시간이 **2배**로 걸린다.
    - C++ 컴파일러는 구조체 내 각 필드의 시작 주소가 필드 크기의 배수인 바이트 주소가 되도록 정렬한다.
        - 사용되지 않는 데이터가 구조체에 포함되어 구멍이 생기는 문제를 초래한다.
        - 구조체에서 **데이터 필드**의 **크기**와 **순서**에 주의를 기울여야한다.
3. 메모리마다 **접근 속도가 다르다**.
    - 캐시메모리
        1. 일반적으로 가장 오래전에 사용된 데이터를 삭제한다.
            - 더 많이 사용하는 메모리 위치에 더 빠르게 접근할 수 있다.
        2. 캐시에 없는 데이터를 1바이트만 읽어도 근처에 있는 바이트가 함께 캐싱된다.
            - 인접한 위치의 메모리가 멀리 떨어진 곳의 메모리보다 더 빨리 접근할 수 있다.
4. 워드를 저장하는 두 가지 방법
    - 빅엔디안
        - 첫 번째 바이트 주소에 최상위 비트가 오는 방법
    - 리틀엔디안
        - 첫 번째 바이트 주소에 최하위 비트가 오는 방법
5. 메모리는 한정된 자원이다.
6. 명령 실행은 느리다.
7. 컴퓨터는 의사 결정을 잘 하지 못한다.
8. 프로그램 실행에는 여러 스트림이 있다.
9. 운영체제 기능을 호출하는 비용은 높다.

### C++도 거짓말을 한다.
1. 문장의 비용이 똑같이 높지는 않다.
2. 문장은 순서대로 실행되지 않는다.