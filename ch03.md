## 성능 측정
- 소프트웨어 제작사들이 시간 측정을 위해 만든 도구
    - 프로파일러 (일반적으로 컴파일러 제작사가 컴파일러와 함께 제공)
    - 소프트웨어 타이머 (개발자가 만들 수 있는 도구)
    - 노트(구식이지만 없어서는 안 될 중요한 도구)
### 사고방식 최적화
1. 성능은 반드시 측정해야 한다.
    - 테스트 가능한 **예측**을 만들고, 적어둔다.
    - 코드 변경 사항을 **기록**한다.
    - 사용 가능한 **최고의 측정기**로 측정한다.
    - 실험 결과의 자세한 내용을 **보관**한다.
2. 최적화를 하는 사람은 맹수 사냥꾼이다.
    - 속도가 빨라졌다고 하려면 `무작위화`, `샘플링`, `신뢰 수준`으로 입증해야 한다.
    - 상당히 힘들고 어려운 일이다.
3. 90/10 규칙
    - `프로그램 코드의 10%가 실행 시간의 90%를 소비한다`
    - 특정 코드 블록이 매우 빈번하게 실행되며 코드의 다른 부분은 거의 실행되지 않는다.
    - 최적화를 하려면 가장 자주 실행되는 10%가 어딘지 찾아야 한다.
4. 암달의 법칙
    - 코드의 일부를 최적화 할 때 전반적인 성능이 얼마나 향상되었는지 설명하는 법칙
    - ![암달](https://user-images.githubusercontent.com/21440957/78467487-51167b80-7748-11ea-802b-228ddf3a656f.PNG)
    - S<sub>t</sub> : 최적화로 프로그램 전체 실행 시간이 얼마나 개선되었는지 나타내는 비율
    - P : 최적화할 부분이 기존 프로그램 전체 실행 시간에서 차지하는 비율
    - S<sub>p</sub> : P에서 최적화로 얼마나 개선되었는지 나타내는 비율

### 실험 수행
1. 연구 노트를 보관하세요  
    - 각 테스트를 **문서화**하면 반복 수행을 빠르게 할 수 있다.
    - **문서화** 하지 않았다면 이전 실험을 다시 수행해 실행 결과를 얻어야 한다.
2. 성능 측정 기준과 목표 설정
    - 팀으로 일하는 개발자라면 관리자와 이해 당사자 모두를 만족하는 최적화를 하여야 한다.
    - 최적화와 관련된 두가지 지표 : `최적화 이전의 성능 축정 기준`, `성능 목표`
    - 최적화는 노력에 대한 보상이 점점 줄어드는 과정이다.
    - 시작 시간
        - 일반적으로 `main() 프로시저`에 들어가는 시점부터 `main 루프`에 들어가는 시점
    - 종료 시간
        - 사용자가 닫기 아이콘을 클릭하거나 명령을 입력한 후부터 프로세스가 실제로 종료될 때까지 걸린 시간
        - 메인 윈도우가 종료 명령을 받는 시점부터 main() 함수를 빠져나오는 시점까지의 경과 시간
    - 응답 시간
        - 평균 시간 또는 최악의 경우를 고려한 시간
        - 응답 시간은 10의 거듭제곱 단위로 분류할 수 있다.
            - 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
            - 0.1초 ~ 1초 : 사용자가 제어권을 가짐
            - 1 ~ 10초 : 컴퓨터에 제어권이 있음
            - 10초 이상 : 커피 마실 시간
    - 처리량
        - `응답 시간`의 역수
        - 테스트 작업량 일부에 대한 단위 시간당 평균 작업 수

3. 측정한 것만 개선할 수 있습니다.
    - `단일 함수`, `서브 시스템`, `태스크`, `테스트 케이스`를 최적화 하는 것과 `전체 프로그램`의 성능을 향상하는 것은 `전혀 다른 작업`이다.
    - 컴퓨터 환경에 따라 테스트 설정이 달라지기 때문에 테스트에서 성능 향상을 보아도 실전에서 동일한 성능 향상을 장담하는 경우는 거의 없다.

### 프로그램 실행 프로파일

### 시간이 오래 걸리는 코드

### 코드 비용 추정하기

### 최적화할 코드를 찾는 다른 방법
