## 성능 측정
- 소프트웨어 제작사들이 시간 측정을 위해 만든 도구
    - 프로파일러 (일반적으로 컴파일러 제작사가 컴파일러와 함께 제공)
    - 소프트웨어 타이머 (개발자가 만들 수 있는 도구)
    - 노트(구식이지만 없어서는 안 될 중요한 도구)
### 사고방식 최적화
1. 성능은 반드시 측정해야 한다.
    - 테스트 가능한 **예측**을 만들고, 적어둔다.
    - 코드 변경 사항을 **기록**한다.
    - 사용 가능한 **최고의 측정기**로 측정한다.
    - 실험 결과의 자세한 내용을 **보관**한다.
2. 최적화를 하는 사람은 맹수 사냥꾼이다.
    - 속도가 빨라졌다고 하려면 `무작위화`, `샘플링`, `신뢰 수준`으로 입증해야 한다.
    - 상당히 힘들고 어려운 일이다.
3. 90/10 규칙
    - `프로그램 코드의 10%가 실행 시간의 90%를 소비한다`
    - 특정 코드 블록이 매우 빈번하게 실행되며 코드의 다른 부분은 거의 실행되지 않는다.
    - 최적화를 하려면 가장 자주 실행되는 10%가 어딘지 찾아야 한다.
4. 암달의 법칙
    - 코드의 일부를 최적화 할 때 전반적인 성능이 얼마나 향상되었는지 설명하는 법칙
    - ![암달](https://user-images.githubusercontent.com/21440957/78467487-51167b80-7748-11ea-802b-228ddf3a656f.PNG)
    - S<sub>t</sub> : 최적화로 프로그램 전체 실행 시간이 얼마나 개선되었는지 나타내는 비율
    - P : 최적화할 부분이 기존 프로그램 전체 실행 시간에서 차지하는 비율
    - S<sub>p</sub> : P에서 최적화로 얼마나 개선되었는지 나타내는 비율

### 실험 수행
1. 연구 노트를 보관하세요  
    - 각 테스트를 **문서화**하면 반복 수행을 빠르게 할 수 있다.
    - **문서화** 하지 않았다면 이전 실험을 다시 수행해 실행 결과를 얻어야 한다.
2. 성능 측정 기준과 목표 설정
    - 팀으로 일하는 개발자라면 관리자와 이해 당사자 모두를 만족하는 최적화를 하여야 한다.
    - 최적화와 관련된 두가지 지표 : `최적화 이전의 성능 축정 기준`, `성능 목표`
    - 최적화는 노력에 대한 보상이 점점 줄어드는 과정이다.
    - 시작 시간
        - 일반적으로 `main() 프로시저`에 들어가는 시점부터 `main 루프`에 들어가는 시점
    - 종료 시간
        - 사용자가 닫기 아이콘을 클릭하거나 명령을 입력한 후부터 프로세스가 실제로 종료될 때까지 걸린 시간
        - 메인 윈도우가 종료 명령을 받는 시점부터 main() 함수를 빠져나오는 시점까지의 경과 시간
    - 응답 시간
        - 평균 시간 또는 최악의 경우를 고려한 시간
        - 응답 시간은 10의 거듭제곱 단위로 분류할 수 있다.
            - 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
            - 0.1초 ~ 1초 : 사용자가 제어권을 가짐
            - 1 ~ 10초 : 컴퓨터에 제어권이 있음
            - 10초 이상 : 커피 마실 시간
    - 처리량
        - `응답 시간`의 역수
        - 테스트 작업량 일부에 대한 단위 시간당 평균 작업 수

3. 측정한 것만 개선할 수 있습니다.
    - `단일 함수`, `서브 시스템`, `태스크`, `테스트 케이스`를 최적화 하는 것과 `전체 프로그램`의 성능을 향상하는 것은 `전혀 다른 작업`이다.
    - 컴퓨터 환경에 따라 테스트 설정이 달라지기 때문에 테스트에서 성능 향상을 보아도 실전에서 동일한 성능 향상을 장담하는 경우는 거의 없다.

### 프로그램 실행 프로파일
- 프로파일러
    - 어떤 프로그램이 어디에 시간을 쓰는지 통계 자료를 생성하는 프로그램
    - 각각의 문장이나 함수의 실행 빈도, 각 함수 실행에 걸린 누적 시간을 보여주는 보고서를 만든다.
    - 프로파일러는 한 분야에서만 능력을 발휘한다.
    - 프로파일러가 알아내지 못한 최적화 기회강 ㅣㅆ을 수 있으며 프로파일러 출력을 해석할 때도 문제가 있을 수 있다.
### 시간이 오래 걸리는 코드
1. 측정 시간 '조금' 배우기
    - 측정 실험을 할 때는 완벽함을 망치는 여러 `편차`에 맞서 싸워야 한다.
    - `편차`에는 `불규칙 편차`와 `체계적 편차` 두 가지 유형이 있다.
        - `불규칙 편차`는 측정할 때마다 서로 다른 영향을 미친다.(정밀도)
        - `체계적 편차`는 모든 측정에 유사한 영향을 미친다.(진도)
    - 편차의 측정 지표는 `정밀도`, `진도`가 있다.
    - 시간 측정
        - 시계를 사용하여 소요시간과 비율을 측정한다.
2. 컴퓨터로 시간 측정하기
    - 윈도우에서 `GetTickCount()` 함수
        - 1 밀리초 해상도의 틱 카운트를 부호 없는 32비트 정수로 반환
    - 작업에 걸린 시간 구하기
        - ```cpp
            DWORD start = GetTickCount();
            DWORD end = GetTickCount();
            cout << end - start << " ms"<<endl;
          ```
    - `지연 시간`
        - 작업을 시작하라고 명령을 내린 시점부터 실제로 명령을 시작하는 시점까지의 경과 시간
        - 시간 측정에서 지연 시간이 발생하는 이유는 시계를 시작하고, 실험을 실행하고, 시계를 멈추는 작업을 순차적으로 수행하기 때문이다.
    - 비결정적 행동
        - 컴퓨터는 매우 복잡한 장치라 내부 상태의 변화 때문에 측정할 때 무작위적인 편차가 발생하게 된다.
        - 운영체제는 예측할 수 없는 방법으로 작업을 예약하므로 측정 도중 프로세서와 메모리 버스의 활동이 달라질 수 있다.
3. 측정 장애물 극복하기
    - 위에서 볼때 컴퓨터로 시간을 측정하는것은 여러가지 제한 사항이 존재한다.
    - 과연 컴퓨터로 시간을 측정하는건 불가능하다?
        - 최적화를 이끌어 나가기 위해서는 1% ~ 2% 정도의 정확도만으로 충분하다.
        - **상대적 성능**을 측정한다.
            - 상대적 성능이란 최적화된 코드의 실행 시간 대 기존 코드의 실행 시간의 비율
        - **모듈 테스트**를 측정해 반복성을 향상시키자.
            - 모듈 테스트랑 준비된 입력 데이터를 사용해 단계별로 수행하는 서브시스템 테스트이다.
        - **측정 기준**을 사용해 성능을 튜닝하자.
        - 여러 차레 반복한 결과의 **평균**으로 정확도를 높이자.
        - **우선순위**를 높여 운영체제의 비결정적 행동을 줄이자.
            - `SetPriorityClass()` 함수를 통해 우선순위를 조작할 수 있다.
        - 비결정적인 무언가가 발생해도 **전진**하자.
            - 개발자가 큰 성능 변화를 가져오는 부분만 받아들인다면, 방법론에 크게 신경 쓸 필요가 없다.
4. 스톱워치 클래스 만들기
    - [스톱워치 클래스](CustomTimer.h)
        - C++ 11 이상에서 사용가능한 `chrono`라이브러리를 쓴 Timer 클래스이다.
        - 운영체제 간에 이식이 가능하다.
    - [스톱워치 클래스2](CustomTimer2.h)
        - C++ 버전과 운영체제에 상관없이 이식성이 있다.
        - 윈도우와 리눅스에서 `clock()`함수가 약간 다르게 측정 될 수 있다.
5. 테스트 하네스에서 실행 시간이 긴 함수 측정하기

### 코드 비용 추정하기
1. C++ 문장의 비용 추정하기
2. 반복문의 비용 추정하기

### 최적화할 코드를 찾는 다른 방법
