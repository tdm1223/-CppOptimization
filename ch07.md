# 문장 최적화
- 문장 수준에서 이뤄지는 최적화는 프로그램을 실행할 때 불필요한 명령어를 제거하는 과정
- 반복문
    - 반복문 안에 있는 문장의 비용을 계산할 때는 문장의 비용을 반복 횟수만큼 곱한다.
- 자주 호출되는 함수
    - 함수의 비용을 계산할 때는 함수의 호출 횟수만큼 곱한다.
- 프로그램 전체에서 사용되는 관용구

## 1. 반복문에서 코드 제거하기
- 반복문의 두 부분
    1. 블록으로 둘러싸여 반복 실행되는 문장들
        - C++ 문장에서 계산을 제거하는 일반적인 기법 적용 가능
    2. 반복 횟수를 경정하는 제어문
        - 어떤 의미에서는 오버헤드이므로 최적화 할 수 있는 여지 존재
- 최적화 되지 않은 `for`문 예제
```cpp
char s[] = "This string has many space (0x20) chars. ";
for(size_t i = 0; i < strlen(s); ++i)
    if(s[i] == ' ')
        s[i] = '*';
```
- `for`문에서 문자마다 조건식 i < strlen(s)를 수행한다.
- 알고리즘의 비용은 O(n<sup>2</sup>)이 된다.

### 1. 반복문의 종료값을 캐싱하기
- 위 예제에서 strlen()의 반환값을 초기화 표현식에서 미리 계산해 캐싱하면 성능을 향상할 수 있다.
```cpp
for(size_t i = 0, len = strlen(s); i < len; ++i)
    if(s[i] == ' ')
        s[i] = '*';
```
- 캐싱만 했을 뿐인데 첫번째 코드보다 속도가 약 **20배**정도 빨라진다.

### 2. 더 효율적인 반복문 사용하기
- C++에서 `for`문의 문법
    - `for (초기화 표현식; 조건식; 증감문) 반복해서 실행할 코드`
- 대략적인 컴파일 결과
```
초기화 표현식;
L1: if (!조건식) goto L2;
      반복해서 실행할 코드;
      증감문;
      goto L1;
L2:
```
- 조건식의 결과가 false일 경우 한 번, 증감문을 계산한 후에 한 번, 총 두 번 점프해야 한다.
    - 이 점프로 실행 속도가 저하될 수 있다.

- C++에서 `do-while` 문
    - `do 반보갷서 실행할 코드 while (조건식);`
- 대략적인 컴파일 결과
```
L1: 반복해서 실행할 코드
    if (조건식) goto L1;
```
- `for` 문은 **경우에 따라** 속도가 더 빠른 `do-while`문으로 바꿀 수 있다. (항상 빨라지는것은 아니다)
```cpp
size_t i = 0, len = strlen(s);
do {
    if (s[i] == ' ')
        s[i] = ' ';
    ++i;
} while (i < len);
```
- `for` 문에 비해 비주얼 스튜디오 2010에서는 32% 향상되었지만 비주얼 스튜디오에서는 25% 저하되었다.

### 3. 값을 증가하는 대신 감소하게 하기
- 종료값을 캐싱하는 예제의 증감문에서 값을 증가하는 대신 감소하도록 변형할 수 있다.
- `1에 있는 예제`에서 종료조건인 `strlen()`은 비용이 많이 들기 때문에 증감문을 감소하는쪽으로 변형한다.
```cpp
for (int i = (int)strlen(s)-1; i >= 0; --i)
    if (s[i] == ' ')
        s[i] = '*';
```

### 4. 반복문에서 불변 코드를 제거하기
```cpp
int i, j, x, a[10];
for (i = 0; i < 10; ++i)
{
    j = 100;
    a[i] = i * j * x * x;
}
```
- 위 코드에서 j=100, j * x * x는 반복문에 대해 불변한다.
```cpp
int i, j, x, a[10];
j = 100; // 반복문 밖으로 뺀다.
int tmp = j * x * x; // 미리 계산해 둔다.
for (i = 0; i < 10; ++i)
{
    a[i] = i + tmp;
}
```
- 최신 컴파일러는 위 예제처럼 반복해서 계산하는 불변코드를 찾아 성능을 향상시키고자 코드를 반복문 바깥으로 옮긴다.
- 반복문에 대해 불변인 함수 호출은 개발자가 직접 확인해 옮겨야 한다.

### 5. 반복문에서 불필요한 함수 호출 제거하기
- `순수함수` : 반환값이 함수의 인수에만 의존하며 사이드 이펙트가 없는 함수
    - 반복문 바깥으로 항상 옮길 수 있는 함수이다.
- 시간 절약이 중요하다면 반복문 안에 있는 모든 함수의 호출을 살펴봐야 한다.

### 6. 반복문에서 숨겨진 함수 호출을 제거하기
- 아래와 같은 경우에서 숨겨진 함수 호출의 가능성이 존재한다.
1. 생성자 호출
    - 클래스 인스턴스의 선언
    - 클래스 인스턴스의 초기화
2. 대입 연산자 호출
    - 클래스 인스턴스의 대입
3. 연산자 멤버 함수 호출
    - 클래스 인스턴스를 포함하는 산술 표현식
4. 범위에서 선언된 클래스 인스턴스의 소멸자 호출
    - 범위를 빠져나갈때
5. 각 인수 표현식은 형식 인수로 복사 생성
    - 함수 인수
6. 복사 생성자 호출
    - 클래스 인스턴스의 함수 반환
7. 항목이 이동 또는 복사 생성
    - 표준 라이브러리 컨테이너에 항목을 삽입
    - 벡터에 항목을 삽입
```cpp
for (...){
    std::string s("<p>");
    ...
    s += "</p>"; 
} // s의 소멸자 호출
```
- `s`를 선언하는 문장을 `for`문에 넣을 경우 비용이 많이 든다.
- 블록으로 둘러싸인 문장에서 닫는 중괄호에 도달시 s의 소멸자가 호출된다.
```cpp
std::string s("<p>");
for (...){
    s.clear();
    s += "<p>";
    ...
    s += "</p>";
}
```
- `s`의 소멸자는 호출되지 않는다.
- 이런 작동은 문자열이나 동적 메모리를 포함하는 클래스에 국한되지 않는다.
    - 클래스 인스턴스는 윈도우나 파일 핸들과 같이 운영체제에서 가져온 자원을 포함하거나 생성자와 소멸자 내부에서 비용이 큰 코드를 수행할 수도 있다.
    
### 7. 반복문에서 비용이 크고 변화가 느린 호출을 제거하기
- 반복문을 호출하는 코드 중에는 불변은 아니지만 불변이라면 더 좋은 경우가 존재한다.
    - 로그를 기록하는 프로그램에서 현재 시각을 구하기 위해 함수를 호출하는 경우
- 현재 시간은 컴퓨터의 명령어 실행 속도보다 매우 느리게 변한다.
- 시간을 텍스트 형식으로 지정해 문자 배열에 저장하는 커스텀 함수가 있다면
```cpp
char* timetoa(char* buf, size_t bufsz){
    time_t t = std::time(nullptr);
    tm tm = *std::localtime(&t);
    size_t sz = std::strftime(buf, bufsz, "%c", &tm);
    if(sz==0) strcpy(buf, "xx:xx:xx"); // 오류
    return buf;
} // 무려 700나노초나 걸린다.

out << "Fri Jan 01 00:00:00 2021" << "Test log line test log line test log line\n"; // 약 372 나노초가 걸린다.
out << timetoa(buf, sizeof(buf)) << "Test log line test log line test log line\n"; // 약 1042 나노초가 걸린다.
```
- 위 두 코드의 실행 시간은 2배가 넘게 차이가 난다.
- 현재 시간을 가져오는 함수를 두 번 연속해서 호출하면 같은 값을 반환할 가능성이 크다.
    - 한번에 여러 줄을 로그로 기록한다면 줄마다 시간을 다시 가져오는게 좋다.

### 8. 반복문을 함수 안에 넣어 호출 오버헤드를 줄이기
- 프로그램이 문자열, 배열, 자료구조를 반복하여 매번 함수를 호출한다면 반복문 뒤집기라는 기법을 사용해 성능을 향상할 수 있다.
- 함수의 인터페이스가 단일 항목을 참조하지 않고 자료구조 전체를 함조하게 된다.

- 출력하지 않는 문자를 점 문자로 바꾸는 라이브러리 함수를 예로 들어보자
```cpp
void replace_nonprinting(char& c){
    if(!isprint(c))
        c = '.';
}
```
- 문자열에서 출력하지 않는 문자를 모두 바꾸고 싶다면 반복문으로 `replace_nonprinting` 함수를 호출하면 된다.
```cpp
for (unsigned i = 0; e = str.size(); i < e; ++i){
    replace_nonprinting(str[i]);
}
```

- 컴파일러가 `replace_nonprintin` 함수를 호출하는 코드를 인라인 할 수 없다면 문자열 `Ring the carriage bell\x07\x07!!`을 처리하기 위해 반복문에서 함수를 **26번** 호출할 것이다.

- `replace_nonprinting` 함수에 오버로드를 추가해 문자열 전체를 처리하도록 만들 수 있다.
```cpp
void replace_nonprinting(std::String& str){
    for(unsigned i = 0, e = str.size(); i < e; ++i))
        if(!isprint(str[i]))
            c = '.';
}
```
- 반복문은 함수안에 있다. 따라서 `replace_nonprinting` 함수를 n-1번 호출하는 비용을 절약했다.
```cpp
void replace_nonprinting(std::string& str){
    for (unsigned i = 0, e = str.size(); i < e; ++i)
        replace_nonprinting(str[i]);
}
```

### 9. 어떤 행동을 하는 횟수를 줄이기
### 10. 그 밖에 다른 기법

## 2. 함수에서 코드 제거하기
### 1. 함수 호출 비용
### 2. 간단한 함수는 인라인으로 선언하기
### 3. 함수를 처음 사용하기 전에 전의하기
### 4. 사용하지 않는 다형성을 제거하기
### 5. 사용하지 않는 인터페이스를 버리기
### 6. 템플릿으로 컴파일 타임에 구현을 선택하기
### 7. PIMPL 관용구를 사용하는 코드를 제거하기
### 8. DLL을 호출하는 코드를 제거하기
### 9. 멤버 함수 대신 정적 멤버 함수를 사용하기
### 10. 가상 소멸자를 기본 클래스로 옮기기

## 3. 표현식 최적화
### 1. 표현식을 단순하게 만들기
### 2. 상수를 함께 모으기
### 3. 비용이 적은 연산자를 사용하기
### 4. 부동 소수점 연산 대신 정수 연산을 사용하기
### 5. double이 float보다 빠를 수 있다
### 6. 반복 계산을 닫힌 형태로 바꾸기

## 4. 제어 흐름 최적화
### 1. if-elseif-else 대신 switch를 사용하기
### 2. switch나 if 대신 가상 함수를 사용하기
### 3. 비용이 들지 않는 예외 처리를 사용하기
